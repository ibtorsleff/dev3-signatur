# Phase 3.5: Legacy Localization/Globalization System in Blazor - Research

**Researched:** 2026-02-17
**Domain:** Localization/Globalization, Database-backed translations, ASP.NET Core IStringLocalizer
**Confidence:** HIGH

## Summary

The legacy Signatur application uses a custom localization system built on a `Localization` database table. The `Globalization` class provides `Get(key, languageId)` methods that query this table, with an in-memory cache (`FLCache` -- a static `Hashtable`) that is bulk-loaded at application startup via `CacheLocalization()`. Page classes access this through `BasePage.GetText(key, args...)` which resolves the current user's `UserLanguageId` from session and delegates to `Globalization.Get()`.

The Blazor app needs an equivalent system. The recommended approach is to implement a custom `ILocalizationService` interface in the Application layer (not `IStringLocalizer` -- see rationale below) backed by `IMemoryCache`, with a hosted service that bulk-loads all translations at startup. Components consume the service via `@inject`. The existing `IUserSessionContext.UserLanguageId` provides the language ID, matching how the legacy `BasePage.UserLanguageId` works.

**Primary recommendation:** Build a `ILocalizationService` with `GetText(key, params)` methods in the Application layer, implement it in Infrastructure with EF Core + `IMemoryCache`, bulk-load cache at startup via `IHostedService`, and inject the service into Blazor components.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Microsoft.Extensions.Caching.Memory | (built-in) | In-memory cache for translations | Built into ASP.NET Core, singleton, replaces legacy FLCache |
| Microsoft.EntityFrameworkCore | 10.0.0 | Query Localization table | Already in use in project |
| Microsoft.Extensions.Hosting | (built-in) | IHostedService for cache warming | Standard pattern for startup tasks |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Microsoft.Extensions.Localization | (built-in) | IStringLocalizer/IStringLocalizerFactory interfaces | Only if we want to integrate with ASP.NET Core localization pipeline |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom ILocalizationService | IStringLocalizer<T> implementation | IStringLocalizer uses culture-based lookup (CultureInfo), legacy uses integer LanguageId. Adapting to IStringLocalizer adds complexity for no benefit since the legacy system is key+languageId-based, not culture-based. Components would need `@inject IStringLocalizer<SharedResource>` which hides the language ID logic. |
| IMemoryCache | ConcurrentDictionary<string, string> | IMemoryCache provides DI integration, expiration, cache metrics. ConcurrentDictionary is simpler but lacks these features. |
| IHostedService cache warming | Lazy loading only | Legacy app pre-loads everything at startup. Lazy loading would cause first-request latency for each key. Bulk load matches legacy behavior. |

## Architecture Patterns

### Recommended Project Structure
```
src/
├── SignaturPortal.Application/
│   ├── Interfaces/
│   │   └── ILocalizationService.cs          # Interface: GetText(key), GetText(key, args)
│   └── Enums/
│       └── AppLanguage.cs                   # Language enum (EN=1, DK=3, DE=4, ES=5)
├── SignaturPortal.Infrastructure/
│   ├── Data/
│   │   └── Entities/
│   │       └── Localization.cs              # EF Core entity (scaffold from Localization table)
│   ├── Localization/
│   │   ├── LocalizationService.cs           # ILocalizationService impl with IMemoryCache
│   │   └── LocalizationCacheWarmupService.cs # IHostedService to bulk-load at startup
│   └── Data/
│       └── SignaturDbContext.cs              # Add DbSet<Localization>
└── SignaturPortal.Web/
    └── Components/
        └── _Imports.razor                   # Add @using for localization namespace
```

### Pattern 1: ILocalizationService Interface (Application Layer)
**What:** Thin interface matching legacy GetText overloads
**When to use:** All components needing translated text
**Example:**
```csharp
// Application/Interfaces/ILocalizationService.cs
public interface ILocalizationService
{
    string GetText(string key);
    string GetText(string key, int languageId);
    string GetText(string key, params string[] args);
    string GetText(string key, int languageId, params string[] args);
    bool TextExists(string key);
}
```

### Pattern 2: Scoped Service with UserLanguageId Resolution
**What:** The service resolves the current user's language from IUserSessionContext
**When to use:** Default GetText(key) calls that use the current user's language
**Example:**
```csharp
// Infrastructure/Localization/LocalizationService.cs
public class LocalizationService : ILocalizationService
{
    private readonly IMemoryCache _cache;
    private readonly IDbContextFactory<SignaturDbContext> _dbFactory;
    private readonly IUserSessionContext _session;

    private const int FallbackLanguageId = 1; // Language.EN

    public string GetText(string key)
    {
        return GetText(key, _session.UserLanguageId > 0 ? _session.UserLanguageId : FallbackLanguageId);
    }

    public string GetText(string key, int languageId)
    {
        var cacheKey = $"loc_{languageId}_{key}";
        if (_cache.TryGetValue(cacheKey, out string? value))
            return value!;

        // On-demand lookup (cache miss after startup)
        // Query DB, cache result, return
        // ...
    }
}
```

### Pattern 3: Bulk Cache Warming via IHostedService
**What:** Load all Localization rows into IMemoryCache at application startup
**When to use:** Application startup -- equivalent to legacy Global.asax CacheLocalization()
**Example:**
```csharp
// Infrastructure/Localization/LocalizationCacheWarmupService.cs
public class LocalizationCacheWarmupService : IHostedService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly IMemoryCache _cache;
    private readonly ILogger<LocalizationCacheWarmupService> _logger;

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        using var scope = _scopeFactory.CreateScope();
        var dbFactory = scope.ServiceProvider.GetRequiredService<IDbContextFactory<SignaturDbContext>>();
        using var db = await dbFactory.CreateDbContextAsync(cancellationToken);

        var entries = await db.Localizations
            .Where(l => l.Enabled)
            .Select(l => new { l.Key, l.LanguageId, l.Value })
            .ToListAsync(cancellationToken);

        foreach (var entry in entries)
        {
            var cacheKey = $"loc_{entry.LanguageId}_{entry.Key}";
            _cache.Set(cacheKey, entry.Value, new MemoryCacheEntryOptions
            {
                Priority = CacheItemPriority.NeverRemove
            });
        }

        _logger.LogInformation("Localization cache warmed: {Count} entries", entries.Count);
    }

    public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask;
}
```

### Pattern 4: Component Consumption via @inject
**What:** Blazor components inject ILocalizationService directly
**When to use:** Every Blazor component/page that needs localized text
**Example:**
```razor
@inject ILocalizationService L

<MudText>@L.GetText("DraftActivities")</MudText>
<MudTooltip Text="@L.GetText("ShowFilters")">
```

### Anti-Patterns to Avoid
- **Do NOT implement IStringLocalizer<T>:** The legacy system uses integer LanguageId, not CultureInfo. Wrapping this in IStringLocalizer adds complexity (you'd need to map CultureInfo back to integer LanguageId) with zero benefit. The project has no existing .resx files.
- **Do NOT create a base component class for GetText:** Unlike legacy `BasePage`, Blazor components should use service injection. A base class creates tight coupling and inheritance chains. `@inject ILocalizationService L` is cleaner and more testable.
- **Do NOT use per-request database queries without caching:** The legacy system caches everything. Database queries on every GetText call would be catastrophic for performance since a single page can have 50+ GetText calls.
- **Do NOT use static/global state for the cache:** Unlike legacy `FLCache` (static Hashtable), use `IMemoryCache` which integrates with DI and is testable.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| In-memory cache | Custom static Dictionary/Hashtable | `IMemoryCache` | Thread-safe, DI-integrated, supports eviction policies, testable |
| Startup task | Custom Task.Run in Program.cs | `IHostedService` | Standard pattern, proper lifecycle, graceful shutdown |
| DB access in singleton | Scoped DbContext in singleton | `IServiceScopeFactory` + scope | Blazor Server scoping rules require factory pattern |
| String formatting | Custom format logic | `string.Format(value, args)` | Matches legacy behavior exactly |

**Key insight:** The legacy `FLCache` is just a static `Hashtable` with lock-based thread safety. `IMemoryCache` provides all this plus DI integration, eviction policies, and size limits -- no need to replicate FLCache's behavior manually.

## Common Pitfalls

### Pitfall 1: Cache Key Mismatch Between Warmup and Lookup
**What goes wrong:** The legacy code has two different cache key patterns: `CacheLocalization()` stores as `{languageId}_Localization_{key}` while `Get(key, languageId)` looks up with `-1_Localization_{key}_LanguageId_{languageId}`. The `Get(key, args, languageId)` uses the warm cache pattern. This dual pattern causes cache misses in legacy.
**Why it happens:** Organic code growth over time in legacy.
**How to avoid:** Use ONE consistent cache key pattern: `loc_{languageId}_{key}`. Both warmup and on-demand lookup must use the same pattern.
**Warning signs:** GetText returns "N/A" for keys that should exist.

### Pitfall 2: DbContext Lifetime in Blazor Server
**What goes wrong:** Using a scoped DbContext in a singleton service (IHostedService) throws ObjectDisposedException.
**Why it happens:** IHostedService is singleton, DbContext is scoped. The scope ends before the hosted service.
**How to avoid:** Use `IServiceScopeFactory` to create a temporary scope, or use `IDbContextFactory<SignaturDbContext>` directly. The project already uses the factory pattern.
**Warning signs:** "Cannot access a disposed context instance" errors at startup.

### Pitfall 3: Language Fallback Logic
**What goes wrong:** Missing translation returns "N/A" or wrong language.
**Why it happens:** Legacy falls back from requested language to English (Language.EN = 1). If no English entry exists, returns "N/A".
**How to avoid:** Implement the same two-step fallback: (1) try requested languageId, (2) try Language.EN (1), (3) return "N/A". The DebugLang mode (returns `[key]` for missing) should also be ported for developer convenience.
**Warning signs:** Danish users see English text unexpectedly, or "N/A" appears in UI.

### Pitfall 4: IMemoryCache is Not Enumerable
**What goes wrong:** Need to clear "all localization entries" for cache management page, but IMemoryCache doesn't support enumeration.
**Why it happens:** IMemoryCache intentionally does not expose enumeration (it's a key-value store, not a collection).
**How to avoid:** Use a `CancellationTokenSource` pattern: store all localization entries with a shared `CancellationChangeToken`. To clear, cancel the token source, which evicts all entries. Then re-warm the cache. Alternatively, maintain a separate `HashSet<string>` of cache keys for administration.
**Warning signs:** Cache clear button does nothing, or cache status page shows no entries.

### Pitfall 5: Missing UserLanguageId on First Request
**What goes wrong:** UserLanguageId is 0 (default int) when session hasn't been initialized.
**Why it happens:** Session data comes from legacy app via System.Web Adapters. If session is not yet established or user is anonymous, UserLanguageId will be 0.
**How to avoid:** Default to Language.DK (3) when UserLanguageId is 0 or invalid, matching legacy BasePage behavior which falls back to site default language (Danish for this deployment).
**Warning signs:** Users see "N/A" or English text when they should see Danish.

## Code Examples

### Localization Entity (EF Core scaffold)
```csharp
// Infrastructure/Data/Entities/Localization.cs
namespace SignaturPortal.Infrastructure.Data.Entities;

public class Localization
{
    public int LocalizationId { get; set; }
    public string Key { get; set; } = string.Empty;
    public string Value { get; set; } = string.Empty;
    public int LanguageId { get; set; }
    public bool Enabled { get; set; }
}
```
Note: The exact column names and primary key need to be verified by scaffolding from the database. The table may use `LocalizationId` as PK or a composite key of `(Key, LanguageId)`.

### Language Enum
```csharp
// Application/Enums/AppLanguage.cs
namespace SignaturPortal.Application.Enums;

/// <summary>
/// Mirrors legacy GenericObjects.Language enum values.
/// Values must match database LanguageId integers exactly.
/// </summary>
public enum AppLanguage
{
    Default = 0,
    EN = 1,   // English
    DK = 3,   // Danish
    DE = 4,   // German
    ES = 5    // Spanish
}
```

### DbContext Registration
```csharp
// In SignaturDbContext.cs (add to partial class)
public virtual DbSet<Localization> Localizations { get; set; }

// In OnModelCreating or OnModelCreatingPartial
modelBuilder.Entity<Localization>(entity =>
{
    entity.ToTable("Localization");
    // Map columns based on actual schema
    entity.Property(e => e.Key).HasMaxLength(128).IsUnicode(false);
    entity.Property(e => e.Value);
    entity.Property(e => e.LanguageId);
    entity.Property(e => e.Enabled);
});
```

### DI Registration
```csharp
// In Infrastructure/DependencyInjection.cs
services.AddMemoryCache(); // Singleton IMemoryCache
services.AddScoped<ILocalizationService, LocalizationService>();
services.AddHostedService<LocalizationCacheWarmupService>();
```

### Component Usage (replacing hardcoded strings)
```csharp
// Before (ActivityList.razor.cs)
_headlineText = newStatus switch
{
    ERActivityStatus.Draft => "Kladdesager",
    ERActivityStatus.Closed => "Afsluttede sager",
    _ => "Igangv\u00e6rende sager"
};

// After
_headlineText = newStatus switch
{
    ERActivityStatus.Draft => L.GetText("DraftActivities"),
    ERActivityStatus.Closed => L.GetText("ClosedActivities"),
    _ => L.GetText("OngoingActivities")
};
```

### Cache Management (Admin Endpoint or Page)
```csharp
// Minimal API endpoint for cache clear (admin only)
app.MapPost("/admin/cache/localization/clear", async (
    LocalizationCacheWarmupService warmup,
    IMemoryCache cache) =>
{
    // Clear and re-warm
    // Use CancellationToken pattern or tracked keys
    await warmup.ReloadAsync();
    return Results.Ok("Localization cache reloaded");
}).RequireAuthorization("RecruitmentAdmin");
```

## Legacy System Deep Dive

### Localization Table Schema (from code analysis)
Based on the SQL in `Globalization.cs`:
- **Table:** `Localization`
- **Columns:** `Key` (varchar 128), `Value` (string), `LanguageId` (int), `Enabled` (bit)
- **Query:** `SELECT Value FROM Localization WHERE [Key] = @key AND LanguageId = @languageId AND Enabled = 1`
- **Note:** Exact PK/schema must be verified by scaffolding. The table may have additional columns.

### Language ID Mapping (from GenericObjects.Language enum)
| Language | ID | Culture |
|----------|----|---------|
| Default | 0 | (fallback) |
| English | 1 | en-US |
| Danish | 3 | da-DK |
| German | 4 | de-DE |
| Spanish | 5 | es-ES |

### GetText Call Patterns in Legacy
The `BasePage` provides these overloads (all forwarding to `Globalization.Get`):
1. `GetText(key)` -- most common, uses current user's language
2. `GetText(key, arg1)` -- single format argument
3. `GetText(key, arg1, arg2)` -- two format arguments
4. `GetText(key, arg1, arg2, arg3)` -- three format arguments
5. `GetText(key, arg1, arg2, arg3, arg4)` -- four format arguments
6. `GetText(key, string[] args)` -- array of arguments
7. `GetText(key, languageId)` -- explicit language override
8. `TextExists(key)` -- checks if Danish translation exists

### FLCache Details
- Static `Hashtable` with `lock(cache.SyncRoot)` for thread safety
- Key format: `{siteId}_{moduleName}_{uniqueName}`
- For Localization module: siteId is languageId (overloaded meaning)
- `CachingEnabled` reads from `ConfigurationManager.AppSettings["CachingEnabled"]`
- `ClearByModuleName("Localization")` clears all localization entries
- No expiration -- entries persist until explicitly cleared or app restart

### Places Where Hardcoded Danish Strings Exist in Blazor
Verified by codebase search -- these files contain hardcoded Danish strings that should use GetText:
1. `ActivityList.razor.cs` -- "Igangvaerende sager", "Kladdesager", "Afsluttede sager"
2. `NavigationConfigService.cs` -- "Rekruttering", "Sagsliste", "Sog", "Hjaelp", "Admin", "Statistik", "Kladdesager", "Igangvaerende sager", "Afsluttede sager", etc.
3. `ActivityList.razor` -- "Skjul filtre", "Vis filtre", column titles ("Headline", "Deadline", "Responsible", etc.)

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| IStringLocalizer with .resx files | IStringLocalizer still standard, but custom impls common | Always | Custom DB-backed localizer is well-supported pattern |
| System.Runtime.Caching.MemoryCache | Microsoft.Extensions.Caching.Memory.IMemoryCache | ASP.NET Core 1.0+ | IMemoryCache is the recommended cache for ASP.NET Core |
| HybridCache (new in .NET 9) | Available but overkill for this use case | .NET 9 | HybridCache adds stampede protection + L1/L2 caching. Not needed here since we bulk-load everything at startup. |

**Deprecated/outdated:**
- `System.Runtime.Caching.MemoryCache`: Still works but not recommended for new ASP.NET Core code. Use `IMemoryCache` instead.
- `IDistributedCache` for this scenario: Unnecessary since both legacy and Blazor apps run on single server. In-memory cache matches legacy behavior.

## Open Questions

1. **Localization Table Exact Schema**
   - What we know: Columns include Key (varchar 128), Value, LanguageId (int), Enabled (bit) based on SQL in Globalization.cs
   - What's unclear: Primary key definition, whether there are additional columns (Id, CreateDate, etc.), exact data types for Value column
   - Recommendation: Scaffold the entity from the database using `dotnet ef dbcontext scaffold` targeting just the Localization table. This is mandatory before implementation.

2. **Legacy Localization Key Inventory**
   - What we know: The Blazor app currently uses hardcoded Danish strings in ~3 files
   - What's unclear: Which legacy localization keys correspond to these strings. We need to look up the actual keys used in the legacy ActivityList pages.
   - Recommendation: Query the Localization table for keys matching "DraftActivities", "OngoingActivities" etc., or check the legacy ActivityList.ascx to find the exact GetText keys used.

3. **Cache Management UI Scope**
   - What we know: Legacy has SysAdmin.aspx with cache status/clear. The requirement mentions Blazor needs equivalent.
   - What's unclear: How elaborate does the admin page need to be? Simple clear button? Or full cache statistics?
   - Recommendation: Start with a minimal API endpoint (POST /admin/cache/localization/clear) behind admin auth. A full Blazor admin page can be added later. This keeps the phase focused.

4. **NavigationConfigService Localization**
   - What we know: NavigationConfigService is registered as singleton, but ILocalizationService needs IUserSessionContext (scoped)
   - What's unclear: How to localize navigation labels that are currently hardcoded in a singleton service
   - Recommendation: NavigationConfigService should return localization keys instead of hardcoded strings. The NavMenu component (which is scoped per circuit) resolves keys via ILocalizationService at render time. This keeps the singleton stateless and the localization user-aware.

## Sources

### Primary (HIGH confidence)
- Codebase analysis: `C:\Dev\Dev3Org\AtlantaSignatur\Library\Common\Globalization.cs` -- legacy localization implementation
- Codebase analysis: `C:\Dev\Dev3Org\AtlantaSignatur\Library\Common\BasePage.cs` -- GetText overloads and UserLanguageId
- Codebase analysis: `C:\Dev\Dev3Org\AtlantaSignatur\Library\FLCaching\FLCache.cs` -- legacy caching implementation
- Codebase analysis: `C:\Dev\Dev3Org\AtlantaSignatur\Library\GenericObjects\GenericObjects.cs` -- Language enum (EN=1, DK=3, DE=4, ES=5)
- Codebase analysis: `C:\Dev\Dev3Org\AtlantaSignatur\Library\Common\LanguageHelper.cs` -- language-to-culture mapping
- Codebase analysis: Blazor project structure (Program.cs, UserSessionContext.cs, DependencyInjection.cs)
- Microsoft Learn: ASP.NET Core Localization Extensibility (https://learn.microsoft.com/aspnet/core/fundamentals/localization-extensibility) -- confirms custom IStringLocalizer with any data source is supported
- Microsoft Learn: Cache in-memory in ASP.NET Core (https://learn.microsoft.com/aspnet/core/performance/caching/memory) -- IMemoryCache patterns, IHostedService cache warming

### Secondary (MEDIUM confidence)
- Microsoft Learn: Blazor Globalization and Localization (https://learn.microsoft.com/aspnet/core/blazor/globalization-localization) -- @inject IStringLocalizer pattern in Blazor
- Microsoft Learn: IHostedService background cache update pattern (https://learn.microsoft.com/dotnet/core/extensions/caching) -- CacheWorker/BackgroundService pattern

### Tertiary (LOW confidence)
- EFStringLocalizer sample project referenced in MS docs (https://github.com/aspnet/Entropy/tree/master/samples/Localization.EntityFramework) -- may be outdated, but confirms pattern is viable

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - IMemoryCache and EF Core are already in use in the project; pattern is well-documented
- Architecture: HIGH - Direct codebase analysis of both legacy and Blazor apps; clean architecture layers already established
- Pitfalls: HIGH - Based on actual code analysis of legacy cache key inconsistencies and Blazor Server scoping rules
- Legacy compatibility: HIGH - Full source code of Globalization.cs, BasePage.cs, FLCache.cs analyzed

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (stable domain, no fast-moving dependencies)
