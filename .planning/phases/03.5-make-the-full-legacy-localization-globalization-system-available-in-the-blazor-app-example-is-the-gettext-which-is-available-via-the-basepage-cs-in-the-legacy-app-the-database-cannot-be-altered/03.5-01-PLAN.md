---
phase: 03.5-localization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SignaturPortal.Domain/Enums/AppLanguage.cs
  - src/SignaturPortal.Application/Interfaces/ILocalizationService.cs
  - src/SignaturPortal.Infrastructure/Data/Entities/Localization.cs
  - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
  - src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs
  - src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs
  - src/SignaturPortal.Infrastructure/DependencyInjection.cs
  - src/SignaturPortal.Web/Program.cs
  - tests/SignaturPortal.Tests/Localization/LocalizationServiceTests.cs
autonomous: true

must_haves:
  truths:
    - "ILocalizationService.GetText(key) returns a localized string from the cache for the current user's language"
    - "All Localization table rows with Enabled=1 are loaded into IMemoryCache at application startup"
    - "Cache miss falls back to on-demand DB query, then caches the result"
    - "Missing translation falls back to English (LanguageId=1), then returns key name if still not found"
    - "UserLanguageId=0 defaults to Danish (LanguageId=3)"
    - "TUnit tests verify GetText, cache hit/miss, language fallback, and string.Format behavior"
  artifacts:
    - path: "src/SignaturPortal.Domain/Enums/AppLanguage.cs"
      provides: "Language enum matching legacy GenericObjects.Language values"
      contains: "EN = 1"
    - path: "src/SignaturPortal.Application/Interfaces/ILocalizationService.cs"
      provides: "ILocalizationService interface with GetText overloads"
      exports: ["ILocalizationService"]
    - path: "src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs"
      provides: "ILocalizationService implementation with IMemoryCache + IDbContextFactory"
      contains: "class LocalizationService"
    - path: "src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs"
      provides: "IHostedService that bulk-loads all enabled Localization rows at startup"
      contains: "class LocalizationCacheWarmupService"
    - path: "src/SignaturPortal.Infrastructure/Data/Entities/Localization.cs"
      provides: "EF Core entity for Localization table"
      contains: "class Localization"
    - path: "tests/SignaturPortal.Tests/Localization/LocalizationServiceTests.cs"
      provides: "TUnit tests for LocalizationService"
      contains: "class LocalizationServiceTests"
  key_links:
    - from: "src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs"
      to: "IMemoryCache"
      via: "cache key pattern loc_{languageId}_{key}"
      pattern: "loc_.*_"
    - from: "src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs"
      to: "SignaturDbContext"
      via: "IDbContextFactory bulk query"
      pattern: "CreateDbContextAsync"
    - from: "src/SignaturPortal.Infrastructure/DependencyInjection.cs"
      to: "LocalizationService"
      via: "DI registration"
      pattern: "AddScoped.*ILocalizationService"
---

<objective>
Build the localization infrastructure: Localization entity, ILocalizationService interface with GetText methods, LocalizationService implementation backed by IMemoryCache, and LocalizationCacheWarmupService that bulk-loads all translations at startup.

Purpose: Replicate the legacy Globalization.Get + FLCache system in ASP.NET Core so Blazor components can call GetText(key) and receive localized strings from the database.
Output: Working localization service that can be injected into any Blazor component via @inject ILocalizationService L.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.5-make-the-full-legacy-localization-globalization-system-available-in-the-blazor-app-example-is-the-gettext-which-is-available-via-the-basepage-cs-in-the-legacy-app-the-database-cannot-be-altered/03.5-RESEARCH.md
@src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
@src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
@src/SignaturPortal.Infrastructure/DependencyInjection.cs
@src/SignaturPortal.Web/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Localization entity, AppLanguage enum, ILocalizationService interface</name>
  <files>
    src/SignaturPortal.Domain/Enums/AppLanguage.cs
    src/SignaturPortal.Application/Interfaces/ILocalizationService.cs
    src/SignaturPortal.Infrastructure/Data/Entities/Localization.cs
    src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
  </files>
  <action>
    **PREREQUISITE -- Schema Discovery (MUST do first, before any code):**
    Run this SQL query against the SignaturAnnoncePortal database to inspect the Localization table schema:
    ```sql
    SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, IS_NULLABLE, COLUMNPROPERTY(OBJECT_ID('Localization'), COLUMN_NAME, 'IsIdentity') AS IsIdentity
    FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'Localization' ORDER BY ORDINAL_POSITION;

    SELECT tc.CONSTRAINT_TYPE, kcu.COLUMN_NAME
    FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
    WHERE tc.TABLE_NAME = 'Localization';
    ```
    Execute via: `sqlcmd -S localhost -d SignaturAnnoncePortal -E -Q "<query>"` or use the EF Core scaffold command: `dotnet ef dbcontext scaffold "..." Microsoft.EntityFrameworkCore.SqlServer --table Localization --output-dir Temp --project src/SignaturPortal.Infrastructure`. Document the actual columns, PK, and data types before proceeding. Delete the Temp folder after inspection.

    1. **Create the Localization entity** at `Infrastructure/Data/Entities/Localization.cs` matching the actual schema discovered above. The research suggests columns: Key (varchar 128), Value, LanguageId (int), Enabled (bit), plus likely a LocalizationId (int, identity) PK. Use the ACTUAL schema from the query above -- do not guess.

    2. **Add DbSet and mapping to SignaturDbContext.cs**: Add `public virtual DbSet<Localization> Localizations { get; set; }` and add `modelBuilder.Entity<Localization>(...)` in OnModelCreating with `entity.ToTable("Localization")` and proper column mappings. Do NOT add any global query filter (this is shared reference data, not tenant-scoped).

    3. **Create AppLanguage enum** at `Domain/Enums/AppLanguage.cs`:
       ```csharp
       namespace SignaturPortal.Domain.Enums;
       public enum AppLanguage
       {
           Default = 0,
           EN = 1,
           DK = 3,
           DE = 4,
           ES = 5
       }
       ```
       Values MUST match legacy GenericObjects.Language exactly (note: 2 is skipped).

    4. **Create ILocalizationService** at `Application/Interfaces/ILocalizationService.cs`:
       ```csharp
       namespace SignaturPortal.Application.Interfaces;
       public interface ILocalizationService
       {
           string GetText(string key);
           string GetText(string key, int languageId);
           string GetText(string key, params object[] args);
           string GetText(string key, int languageId, params object[] args);
           bool TextExists(string key);
           bool TextExists(string key, int languageId);
       }
       ```
       Use `params object[] args` (not `string[]`) to match legacy which accepts any formattable arguments. The overloads with args call string.Format on the raw value.
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.Application` and `dotnet build src/SignaturPortal.Infrastructure` -- both must compile without errors.
  </verify>
  <done>
    Localization entity mapped to database table, AppLanguage enum matches legacy values, ILocalizationService interface defines GetText overloads matching legacy BasePage.GetText signatures.
  </done>
</task>

<task type="auto">
  <name>Task 2: LocalizationService, cache warmup, and DI registration</name>
  <files>
    src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs
    src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs
    src/SignaturPortal.Infrastructure/DependencyInjection.cs
    src/SignaturPortal.Web/Program.cs
  </files>
  <action>
    1. **Create LocalizationService** at `Infrastructure/Localization/LocalizationService.cs`:
       - Implements `ILocalizationService`
       - Constructor injects: `IMemoryCache cache`, `IDbContextFactory<SignaturDbContext> dbFactory`, `IUserSessionContext session`
       - `GetText(key)` resolves language from `_session.UserLanguageId`. If UserLanguageId is 0, default to `(int)AppLanguage.DK` (3) -- matching legacy Danish deployment default.
       - `GetText(key, languageId)`: Look up cache key `$"loc_{languageId}_{key}"`. On cache miss, query DB: `WHERE Key == key AND LanguageId == languageId AND Enabled`. Cache the result with `Priority = CacheItemPriority.NeverRemove`. If no result and languageId != 1, try fallback to English (languageId=1). If still no result, return the key name wrapped in brackets `[{key}]` for debuggability.
       - `GetText(key, params object[] args)` and `GetText(key, int languageId, params object[] args)`: Call the no-args overload, then apply `string.Format(value, args)`. Wrap in try-catch to handle format mismatches gracefully (return unformatted value).
       - `TextExists(key)`: Check if GetText returns something other than `[{key}]`. Default language = DK (3).
       - `TextExists(key, int languageId)`: Same check with explicit language.
       - CRITICAL: Use the exact same cache key pattern `$"loc_{languageId}_{key}"` everywhere -- both in this service and in the warmup service. Research identified legacy cache key mismatch as a critical bug.

    2. **Create LocalizationCacheWarmupService** at `Infrastructure/Localization/LocalizationCacheWarmupService.cs`:
       - Implements `IHostedService`
       - Constructor injects: `IServiceScopeFactory scopeFactory`, `IMemoryCache cache`, `ILogger<LocalizationCacheWarmupService> logger`
       - `StartAsync`: Create scope, get `IDbContextFactory<SignaturDbContext>`, create context, query ALL rows from Localization where Enabled == true, selecting Key, LanguageId, Value. For each entry, set cache key `$"loc_{entry.LanguageId}_{entry.Key}"` with `CacheItemPriority.NeverRemove`. Log count.
       - Add a public `ReloadAsync()` method that re-runs the same logic (for future cache management).
       - `StopAsync`: return Task.CompletedTask.

    3. **Update DependencyInjection.cs** in Infrastructure:
       - Add `services.AddMemoryCache();` (registers singleton IMemoryCache)
       - Add `services.AddScoped<ILocalizationService, LocalizationService>();` (scoped because it needs IUserSessionContext which is scoped)
       - Add `services.AddHostedService<LocalizationCacheWarmupService>();`
       - Add the necessary `using` statements for the Localization namespace.

    4. **Verify Program.cs** does NOT already call `AddMemoryCache()`. If `AddDistributedMemoryCache()` is already there (it is, for session), that is separate -- `AddMemoryCache()` registers the `IMemoryCache` singleton which is different from `IDistributedCache`. Both can coexist.
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.Web` -- must compile. Then run the app briefly (`dotnet run --project src/SignaturPortal.Web`) and check startup logs for "Localization cache warmed: N entries" message. The app should start without errors.
  </verify>
  <done>
    LocalizationService returns cached translations with language fallback. Cache warmup loads all enabled rows at startup. DI wires everything up. App starts and logs cache count.
  </done>
</task>

<task type="auto">
  <name>Task 3: TUnit tests for LocalizationService</name>
  <files>
    tests/SignaturPortal.Tests/Localization/LocalizationServiceTests.cs
  </files>
  <action>
    Create TUnit tests at `tests/SignaturPortal.Tests/Localization/LocalizationServiceTests.cs`. The test project already references Infrastructure and has TUnit + EF Core Sqlite packages.

    **Test setup:** Create a helper that sets up `IMemoryCache` (real `MemoryCache`), a mock/stub `IUserSessionContext`, and a mock/stub `IDbContextFactory<SignaturDbContext>` using EF Core Sqlite in-memory. Seed the Sqlite DB with test Localization rows for multiple languages.

    **Test cases (use `[Test]` attribute, TUnit style):**

    1. **GetText_WithCachedKey_ReturnsCachedValue** -- Pre-populate cache with `loc_3_TestKey` = "TestVaerdi". Call `GetText("TestKey", 3)`. Assert returns "TestVaerdi". Verify DB was NOT queried (no DbContext created).

    2. **GetText_WithCacheMiss_QueriesDbAndCachesResult** -- Do NOT pre-populate cache. Seed DB with a row (Key="DbKey", LanguageId=3, Value="FraDb", Enabled=true). Call `GetText("DbKey", 3)`. Assert returns "FraDb". Call again and verify cache is now populated.

    3. **GetText_WithMissingKey_ReturnsBracketedKeyName** -- Call `GetText("NonExistent", 3)` with no DB or cache entry. Assert returns "[NonExistent]".

    4. **GetText_FallsBackToEnglish_WhenRequestedLanguageMissing** -- Seed DB with (Key="FallbackKey", LanguageId=1, Value="English Fallback", Enabled=true) but NO entry for LanguageId=3. Call `GetText("FallbackKey", 3)`. Assert returns "English Fallback".

    5. **GetText_NoArgs_UsesUserLanguageId** -- Set mock `IUserSessionContext.UserLanguageId` to 3. Pre-populate cache with `loc_3_SessionKey` = "DanishText". Call `GetText("SessionKey")` (no languageId). Assert returns "DanishText".

    6. **GetText_UserLanguageIdZero_DefaultsToDanish** -- Set mock `IUserSessionContext.UserLanguageId` to 0. Pre-populate cache with `loc_3_DefaultKey` = "DanishDefault". Call `GetText("DefaultKey")`. Assert returns "DanishDefault".

    7. **GetText_WithFormatArgs_AppliesStringFormat** -- Pre-populate cache with `loc_3_FormatKey` = "Hello {0}, you have {1} items". Call `GetText("FormatKey", 3, "Alice", 5)`. Assert returns "Hello Alice, you have 5 items".

    8. **GetText_WithBadFormatArgs_ReturnsUnformattedValue** -- Pre-populate cache with `loc_3_BadFormat` = "No placeholders here". Call `GetText("BadFormat", 3, "extra", "args")`. Assert returns "No placeholders here" (no exception thrown).

    9. **TextExists_ReturnsTrueForExistingKey** -- Pre-populate cache. Call `TextExists("TestKey")`. Assert true.

    10. **TextExists_ReturnsFalseForMissingKey** -- Call `TextExists("Missing")`. Assert false.

    **Important:** Use `Microsoft.Extensions.Caching.Memory.MemoryCache` (real, not mocked) for cache tests. Mock `IUserSessionContext` with a simple stub class. For DB tests, use EF Core Sqlite in-memory (`DataSource=:memory:`) with the Localization entity mapped.
  </action>
  <verify>
    Run `dotnet test tests/SignaturPortal.Tests` -- all 10 tests must pass.
  </verify>
  <done>
    10 TUnit tests cover: cache hit, cache miss with DB fallback, missing key bracket notation, English fallback, user language resolution, UserLanguageId=0 default, string.Format args, bad format args safety, TextExists true/false.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SignaturPortal.Web` compiles without errors
2. App starts and logs "Localization cache warmed: {N} entries" with N > 0
3. No runtime errors related to DI resolution or DbContext lifetime
4. `dotnet test tests/SignaturPortal.Tests` -- all 10 LocalizationService tests pass
</verification>

<success_criteria>
- ILocalizationService is injectable in any Blazor component
- GetText(key) returns correct localized strings from the Localization database table
- Cache is pre-warmed at startup (matching legacy CacheLocalization behavior)
- Language fallback chain: requested language -> English -> [key]
- UserLanguageId=0 defaults to Danish (3)
- TUnit tests verify all GetText behaviors: cache hit/miss, fallback, format args, TextExists
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-make-the-full-legacy-localization-globalization-system-available-in-the-blazor-app-example-is-the-gettext-which-is-available-via-the-basepage-cs-in-the-legacy-app-the-database-cannot-be-altered/03.5-01-SUMMARY.md`
</output>
