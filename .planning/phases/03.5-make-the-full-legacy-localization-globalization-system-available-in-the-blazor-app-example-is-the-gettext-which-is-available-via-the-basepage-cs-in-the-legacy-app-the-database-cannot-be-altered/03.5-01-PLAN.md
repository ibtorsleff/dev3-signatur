---
phase: 03.5-localization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SignaturPortal.Domain/Enums/AppLanguage.cs
  - src/SignaturPortal.Application/Interfaces/ILocalizationService.cs
  - src/SignaturPortal.Infrastructure/Data/Entities/Localization.cs
  - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
  - src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs
  - src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs
  - src/SignaturPortal.Infrastructure/DependencyInjection.cs
  - src/SignaturPortal.Web/Program.cs
autonomous: true

must_haves:
  truths:
    - "ILocalizationService.GetText(key) returns a localized string from the cache for the current user's language"
    - "All Localization table rows with Enabled=1 are loaded into IMemoryCache at application startup"
    - "Cache miss falls back to on-demand DB query, then caches the result"
    - "Missing translation falls back to English (LanguageId=1), then returns key name if still not found"
    - "UserLanguageId=0 defaults to Danish (LanguageId=3)"
  artifacts:
    - path: "src/SignaturPortal.Domain/Enums/AppLanguage.cs"
      provides: "Language enum matching legacy GenericObjects.Language values"
      contains: "EN = 1"
    - path: "src/SignaturPortal.Application/Interfaces/ILocalizationService.cs"
      provides: "ILocalizationService interface with GetText overloads"
      exports: ["ILocalizationService"]
    - path: "src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs"
      provides: "ILocalizationService implementation with IMemoryCache + IDbContextFactory"
      contains: "class LocalizationService"
    - path: "src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs"
      provides: "IHostedService that bulk-loads all enabled Localization rows at startup"
      contains: "class LocalizationCacheWarmupService"
    - path: "src/SignaturPortal.Infrastructure/Data/Entities/Localization.cs"
      provides: "EF Core entity for Localization table"
      contains: "class Localization"
  key_links:
    - from: "src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs"
      to: "IMemoryCache"
      via: "cache key pattern loc_{languageId}_{key}"
      pattern: "loc_.*_"
    - from: "src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs"
      to: "SignaturDbContext"
      via: "IDbContextFactory bulk query"
      pattern: "CreateDbContextAsync"
    - from: "src/SignaturPortal.Infrastructure/DependencyInjection.cs"
      to: "LocalizationService"
      via: "DI registration"
      pattern: "AddScoped.*ILocalizationService"
---

<objective>
Build the localization infrastructure: Localization entity, ILocalizationService interface with GetText methods, LocalizationService implementation backed by IMemoryCache, and LocalizationCacheWarmupService that bulk-loads all translations at startup.

Purpose: Replicate the legacy Globalization.Get + FLCache system in ASP.NET Core so Blazor components can call GetText(key) and receive localized strings from the database.
Output: Working localization service that can be injected into any Blazor component via @inject ILocalizationService L.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.5-make-the-full-legacy-localization-globalization-system-available-in-the-blazor-app-example-is-the-gettext-which-is-available-via-the-basepage-cs-in-the-legacy-app-the-database-cannot-be-altered/03.5-RESEARCH.md
@src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
@src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
@src/SignaturPortal.Infrastructure/DependencyInjection.cs
@src/SignaturPortal.Web/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Localization entity, AppLanguage enum, ILocalizationService interface</name>
  <files>
    src/SignaturPortal.Domain/Enums/AppLanguage.cs
    src/SignaturPortal.Application/Interfaces/ILocalizationService.cs
    src/SignaturPortal.Infrastructure/Data/Entities/Localization.cs
    src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
  </files>
  <action>
    1. **Scaffold the Localization entity from the database** using `dotnet ef dbcontext scaffold` targeting the Localization table, OR manually create the entity by querying the DB schema. The research shows columns: Key (varchar 128), Value, LanguageId (int), Enabled (bit). Check for a primary key column (likely LocalizationId or composite key). Create `Infrastructure/Data/Entities/Localization.cs` matching the actual schema.

    2. **Add DbSet and mapping to SignaturDbContext.cs**: Add `public virtual DbSet<Localization> Localizations { get; set; }` and add `modelBuilder.Entity<Localization>(...)` in OnModelCreating with `entity.ToTable("Localization")` and proper column mappings. Do NOT add any global query filter (this is shared reference data, not tenant-scoped).

    3. **Create AppLanguage enum** at `Domain/Enums/AppLanguage.cs`:
       ```csharp
       namespace SignaturPortal.Domain.Enums;
       public enum AppLanguage
       {
           Default = 0,
           EN = 1,
           DK = 3,
           DE = 4,
           ES = 5
       }
       ```
       Values MUST match legacy GenericObjects.Language exactly (note: 2 is skipped).

    4. **Create ILocalizationService** at `Application/Interfaces/ILocalizationService.cs`:
       ```csharp
       namespace SignaturPortal.Application.Interfaces;
       public interface ILocalizationService
       {
           string GetText(string key);
           string GetText(string key, int languageId);
           string GetText(string key, params object[] args);
           string GetText(string key, int languageId, params object[] args);
           bool TextExists(string key);
           bool TextExists(string key, int languageId);
       }
       ```
       Use `params object[] args` (not `string[]`) to match legacy which accepts any formattable arguments. The overloads with args call string.Format on the raw value.
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.Application` and `dotnet build src/SignaturPortal.Infrastructure` -- both must compile without errors.
  </verify>
  <done>
    Localization entity mapped to database table, AppLanguage enum matches legacy values, ILocalizationService interface defines GetText overloads matching legacy BasePage.GetText signatures.
  </done>
</task>

<task type="auto">
  <name>Task 2: LocalizationService, cache warmup, and DI registration</name>
  <files>
    src/SignaturPortal.Infrastructure/Localization/LocalizationService.cs
    src/SignaturPortal.Infrastructure/Localization/LocalizationCacheWarmupService.cs
    src/SignaturPortal.Infrastructure/DependencyInjection.cs
    src/SignaturPortal.Web/Program.cs
  </files>
  <action>
    1. **Create LocalizationService** at `Infrastructure/Localization/LocalizationService.cs`:
       - Implements `ILocalizationService`
       - Constructor injects: `IMemoryCache cache`, `IDbContextFactory<SignaturDbContext> dbFactory`, `IUserSessionContext session`
       - `GetText(key)` resolves language from `_session.UserLanguageId`. If UserLanguageId is 0, default to `(int)AppLanguage.DK` (3) -- matching legacy Danish deployment default.
       - `GetText(key, languageId)`: Look up cache key `$"loc_{languageId}_{key}"`. On cache miss, query DB: `WHERE Key == key AND LanguageId == languageId AND Enabled`. Cache the result with `Priority = CacheItemPriority.NeverRemove`. If no result and languageId != 1, try fallback to English (languageId=1). If still no result, return the key name wrapped in brackets `[{key}]` for debuggability.
       - `GetText(key, params object[] args)` and `GetText(key, int languageId, params object[] args)`: Call the no-args overload, then apply `string.Format(value, args)`. Wrap in try-catch to handle format mismatches gracefully (return unformatted value).
       - `TextExists(key)`: Check if GetText returns something other than `[{key}]`. Default language = DK (3).
       - `TextExists(key, int languageId)`: Same check with explicit language.
       - CRITICAL: Use the exact same cache key pattern `$"loc_{languageId}_{key}"` everywhere -- both in this service and in the warmup service. Research identified legacy cache key mismatch as a critical bug.

    2. **Create LocalizationCacheWarmupService** at `Infrastructure/Localization/LocalizationCacheWarmupService.cs`:
       - Implements `IHostedService`
       - Constructor injects: `IServiceScopeFactory scopeFactory`, `IMemoryCache cache`, `ILogger<LocalizationCacheWarmupService> logger`
       - `StartAsync`: Create scope, get `IDbContextFactory<SignaturDbContext>`, create context, query ALL rows from Localization where Enabled == true, selecting Key, LanguageId, Value. For each entry, set cache key `$"loc_{entry.LanguageId}_{entry.Key}"` with `CacheItemPriority.NeverRemove`. Log count.
       - Add a public `ReloadAsync()` method that re-runs the same logic (for future cache management).
       - `StopAsync`: return Task.CompletedTask.

    3. **Update DependencyInjection.cs** in Infrastructure:
       - Add `services.AddMemoryCache();` (registers singleton IMemoryCache)
       - Add `services.AddScoped<ILocalizationService, LocalizationService>();` (scoped because it needs IUserSessionContext which is scoped)
       - Add `services.AddHostedService<LocalizationCacheWarmupService>();`
       - Add the necessary `using` statements for the Localization namespace.

    4. **Verify Program.cs** does NOT already call `AddMemoryCache()`. If `AddDistributedMemoryCache()` is already there (it is, for session), that is separate -- `AddMemoryCache()` registers the `IMemoryCache` singleton which is different from `IDistributedCache`. Both can coexist.
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.Web` -- must compile. Then run the app briefly (`dotnet run --project src/SignaturPortal.Web`) and check startup logs for "Localization cache warmed: N entries" message. The app should start without errors.
  </verify>
  <done>
    LocalizationService returns cached translations with language fallback. Cache warmup loads all enabled rows at startup. DI wires everything up. App starts and logs cache count.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SignaturPortal.Web` compiles without errors
2. App starts and logs "Localization cache warmed: {N} entries" with N > 0
3. No runtime errors related to DI resolution or DbContext lifetime
</verification>

<success_criteria>
- ILocalizationService is injectable in any Blazor component
- GetText(key) returns correct localized strings from the Localization database table
- Cache is pre-warmed at startup (matching legacy CacheLocalization behavior)
- Language fallback chain: requested language -> English -> [key]
- UserLanguageId=0 defaults to Danish (3)
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-make-the-full-legacy-localization-globalization-system-available-in-the-blazor-app-example-is-the-gettext-which-is-available-via-the-basepage-cs-in-the-legacy-app-the-database-cannot-be-altered/03.5-01-SUMMARY.md`
</output>
