# Phase 03.7: Authentication & User Context -- Migration Strategy - Research

**Researched:** 2026-02-17
**Domain:** Blazor Server authentication, System.Web Adapters remote auth/session, ASP.NET Core authorization
**Confidence:** HIGH

## Summary

This research examines the current authentication and user context architecture in the SignaturPortal Blazor app, identifies concrete gaps and risks, and recommends corrective actions. The project uses System.Web Adapters v2.3.0 for remote authentication and session sharing between a .NET Framework 4.8 WebForms app (Forms Authentication) and a .NET 10 Blazor Server app.

The current implementation has **five actionable issues**: (1) a critical session key type mismatch between legacy and Blazor for `UserId`, (2) missing `AuthorizeRouteView` and `CascadingAuthenticationState` so `[Authorize]` attributes on pages may not function correctly in the Blazor component tree, (3) no redirect-to-login behavior when authentication fails or sessions expire, (4) session persistence is fragile across circuit reconnections, and (5) the `UserSessionContext` has no mechanism to detect or handle stale/expired sessions during long-lived Blazor circuits.

**Primary recommendation:** Fix the five identified gaps in order of severity -- type mismatch first, then Blazor auth infrastructure, then session lifecycle hardening.

## Current Architecture (What Exists Today)

### Authentication Flow

```
User -> Legacy WebForms (Forms Auth login) -> Cookie set
  -> Navigates to Blazor route (localhost:5219)
  -> SSR prerender: System.Web Adapters remote auth
     -> Blazor sends Cookie/Authorization headers to legacy /systemweb-adapters/authenticate
     -> Legacy returns ClaimsPrincipal (serialized)
     -> HttpContext.User populated with remote identity
  -> SSR prerender: UserSessionMiddleware runs
     -> System.Web.HttpContext.Current.Session available
     -> UserSessionContext.Initialize() reads 5 session keys
  -> Blazor component tree renders with session data
  -> PersistentComponentState serializes session values
  -> SignalR circuit starts (interactive mode)
     -> SessionPersistence restores values from PersistentComponentState
     -> No more HTTP pipeline -- session is frozen snapshot
```

### Key Files

| File | Purpose |
|------|---------|
| `src/SignaturPortal.Web/Program.cs` | Auth/session middleware pipeline |
| `src/SignaturPortal.Web/Services/UserSessionContext.cs` | Scoped session value cache |
| `src/SignaturPortal.Web/Middleware/UserSessionMiddleware.cs` | Populates UserSessionContext during SSR |
| `src/SignaturPortal.Web/Components/Layout/SessionPersistence.razor` | Bridges SSR -> SignalR circuit |
| `src/SignaturPortal.Web/Components/Routes.razor` | Router (plain RouteView, NOT AuthorizeRouteView) |
| `src/SignaturPortal.Infrastructure/Authorization/PermissionHandler.cs` | Custom IAuthorizationHandler |
| `src/SignaturPortal.Infrastructure/Services/PermissionService.cs` | DB-backed permission queries |

### Session Keys Registered

| Key | Blazor Type | Legacy Type | Legacy Value |
|-----|-------------|-------------|--------------|
| UserId | `Guid` | `int` (WRONG) | `aUser.UserId` (actually `Guid`) |
| SiteId | `int` | `int` | `aUser.SiteId` |
| ClientId | `int` | `int` | `aUser.ClientId` |
| UserName | `string` | `string` | `aUser.Username` |
| UserLanguageId | `int` | `int` | `(int)aUser.Language` |

## Identified Issues

### Issue 1: UserId Session Key Type Mismatch (CRITICAL)

**What:** The legacy `Global.asax.cs` registers `UserId` as `RegisterKey<int>("UserId")`, but the Blazor side registers it as `RegisterKey<Guid>("UserId")`. The actual value stored is `aUser.UserId` which is a `Guid`.

**Where:**
- Legacy: `C:\Dev\Dev3Org\AtlantaSignatur\Web\MainSite\Global.asax.cs` line 43
- Blazor: `src/SignaturPortal.Web/Program.cs` line 55
- Value source: `GenericObjects.cs` -- `public Guid UserId;`

**Impact:** The JSON session serializer uses the registered type to serialize/deserialize. If legacy registers `int` but stores a `Guid`, the serialization may fail silently or produce garbage. The Blazor side correctly registers `Guid`, but the legacy side must match. This mismatch likely means session sharing for UserId is broken or unreliable.

**Fix:** Change the legacy side to `RegisterKey<Guid>("UserId")`. This is a one-line change in `Global.asax.cs`.

**Confidence:** HIGH -- verified by reading both codebases directly.

### Issue 2: Missing AuthorizeRouteView and CascadingAuthenticationState (HIGH)

**What:** The `Routes.razor` file uses plain `<RouteView>` instead of `<AuthorizeRouteView>`. There is no call to `AddCascadingAuthenticationState()` in `Program.cs`. Pages use `@attribute [Authorize(Policy = "RecruitmentAccess")]` but without `AuthorizeRouteView`, the Blazor component router does not enforce these attributes within the Blazor component tree.

**Where:**
- `src/SignaturPortal.Web/Components/Routes.razor` -- uses `<RouteView>` (line 3)
- `src/SignaturPortal.Web/Program.cs` -- no `AddCascadingAuthenticationState()` call

**How it works currently:** The `[Authorize]` attributes are enforced by ASP.NET Core's authorization middleware at the HTTP pipeline level during SSR prerender. Once the SignalR circuit is established, the middleware does not re-run for component navigations. This means:
- First page load (SSR): Authorization IS enforced via HTTP middleware
- Subsequent SPA navigations within the circuit: Authorization is NOT enforced by the component router (RouteView does not check [Authorize])
- The PermissionHandler still runs if components explicitly call permission checks, but the [Authorize] gate is bypassed

**Impact:** A user who loses their session or permissions during a long circuit can navigate to protected pages via SPA navigation without being challenged. This is a security gap.

**Fix:**
1. Replace `<RouteView>` with `<AuthorizeRouteView>` in `Routes.razor`
2. Add `builder.Services.AddCascadingAuthenticationState();` in `Program.cs`
3. Optionally add `<NotAuthorized>` content to redirect to login

**Confidence:** HIGH -- verified against Microsoft official docs (https://learn.microsoft.com/aspnet/core/blazor/security/?view=aspnetcore-10.0#expose-the-authentication-state-as-a-cascading-parameter).

### Issue 3: No Login Redirect on Auth Failure (MEDIUM)

**What:** When authentication fails (session expired, cookie expired, user navigates directly to Blazor without being logged in), there is no redirect to the legacy login page. The user would see a blank page or an error.

**Where:** No `LoginPath`, no `AccessDeniedPath`, no `<NotAuthorized>` template anywhere in the codebase.

**Impact:** Poor user experience when sessions expire. Users must manually navigate to the legacy app to log in.

**Fix:** Add a `<NotAuthorized>` template in `AuthorizeRouteView` that performs a full-page redirect to the legacy login URL (via `NavigationManager.NavigateTo(legacyLoginUrl, forceLoad: true)`). This keeps the legacy app as the single sign-in authority, consistent with System.Web Adapters' design.

**Confidence:** HIGH -- standard Blazor pattern.

### Issue 4: Session Staleness During Long Circuits (MEDIUM)

**What:** Session values are captured once during SSR and persisted into the SignalR circuit via `PersistentComponentState`. They are never refreshed. A Blazor Server circuit can live for hours. If the user's permissions, language, or tenant assignment changes in the legacy app during that time, the Blazor app operates on stale data.

**Where:** `UserSessionContext.Initialize()` runs once (middleware), `Restore()` runs once (circuit start). No refresh mechanism.

**Impact:** Stale permissions could allow or deny access incorrectly. Stale tenant context could show wrong data. In practice, permission changes are rare during a session, so this is medium severity.

**Fix options:**
1. **Accept staleness** (simplest) -- document that permission changes require a page refresh. This matches typical WebForms behavior where session values are read once per page request.
2. **Periodic refresh** -- add a timer in a layout component that calls a lightweight API endpoint to re-read session values. Only needed if permission changes during a session are a real concern.
3. **Navigate-and-reload** -- on each SPA navigation, use `forceLoad: true` to trigger a full HTTP round-trip. This kills the circuit advantage and is not recommended.

**Recommendation:** Option 1 (accept staleness) is correct for this migration. Legacy WebForms had the same per-request snapshot behavior. Document the limitation.

### Issue 5: Circuit Reconnection Does Not Re-Authenticate (LOW)

**What:** When a Blazor Server circuit is lost and reconnected (network blip), the `PersistentComponentState` is NOT re-read -- it is only available on initial render. The scoped `UserSessionContext` survives the reconnection because the DI scope (circuit scope) is preserved. However, if the circuit cannot reconnect and a new circuit starts, the user gets a fresh scope with an uninitialized `UserSessionContext` and no way to populate it (no SSR, no middleware).

**Where:** `ReconnectModal.razor` handles the UI, but there is no auth recovery logic.

**Impact:** After a failed reconnect + new circuit, the user is effectively unauthenticated in Blazor. The reconnect modal tells them to reload, which triggers a full HTTP round-trip and re-runs SSR + middleware. This is acceptable behavior.

**Recommendation:** No code change needed. The existing reload behavior is correct. Ensure the reconnect modal clearly instructs users to reload.

## Architecture Patterns

### Pattern 1: AuthorizeRouteView with NotAuthorized Redirect

**What:** Standard Blazor Server pattern for enforcing page-level authorization in the component router.
**When to use:** Always, when pages have `[Authorize]` attributes.
**Example:**
```razor
@* Routes.razor *@
<Router AppAssembly="typeof(Program).Assembly" NotFoundPage="typeof(Pages.NotFound)">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)">
            <NotAuthorized>
                <RedirectToLogin />
            </NotAuthorized>
        </AuthorizeRouteView>
        <FocusOnNavigate RouteData="routeData" Selector="h1" />
    </Found>
</Router>
```
Source: https://learn.microsoft.com/aspnet/core/blazor/security/?view=aspnetcore-10.0

### Pattern 2: RedirectToLogin Component

**What:** A small component that redirects unauthenticated users to the legacy login page.
**When to use:** Inside `<NotAuthorized>` of `AuthorizeRouteView`.
**Example:**
```razor
@* Components/Auth/RedirectToLogin.razor *@
@inject NavigationManager Navigation

@code {
    protected override void OnInitialized()
    {
        // Force full page load to go through YARP -> legacy login
        var returnUrl = Uri.EscapeDataString(Navigation.Uri);
        Navigation.NavigateTo($"/Login.aspx?ReturnUrl={returnUrl}", forceLoad: true);
    }
}
```

### Pattern 3: CascadingAuthenticationState Registration

**What:** Makes `Task<AuthenticationState>` available as a cascading parameter throughout the component tree.
**When to use:** Required for `AuthorizeRouteView`, `AuthorizeView`, and `[CascadingParameter] Task<AuthenticationState>`.
**Example:**
```csharp
// Program.cs
builder.Services.AddCascadingAuthenticationState();
```
Source: https://learn.microsoft.com/aspnet/core/blazor/security/?view=aspnetcore-10.0

### Anti-Patterns to Avoid

- **Using RouteView instead of AuthorizeRouteView:** `[Authorize]` attributes are ignored by the Blazor component router, creating a false sense of security.
- **Checking IUserSessionContext.IsInitialized as a substitute for authentication:** This only checks whether session values were read, not whether the user is actually authenticated. A user could have an initialized but expired session.
- **Re-reading System.Web session during SignalR:** `System.Web.HttpContext.Current` is null during SignalR interactions. Never attempt to access it outside of SSR/middleware.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Page-level auth enforcement | Custom middleware checking every route | `AuthorizeRouteView` | Built into Blazor, handles SPA navigation correctly |
| Cascading auth state | Manual `CascadingValue<Task<AuthenticationState>>` | `AddCascadingAuthenticationState()` | One line, handles all edge cases |
| Login redirect | Custom 401-handling middleware | `<NotAuthorized>` template + redirect component | Standard Blazor pattern, works in both SSR and circuit |
| Session serialization type handling | Custom JSON converters | Fix the `RegisterKey<T>` type to match actual value | System.Web Adapters handles serialization correctly when types match |

**Key insight:** The System.Web Adapters already provide the authentication plumbing. The issue is not that auth is missing -- it is that the Blazor component tree is not wired up to USE the auth state that the adapters provide.

## Common Pitfalls

### Pitfall 1: RouteView Silently Ignores [Authorize]

**What goes wrong:** Pages have `[Authorize]` attributes but use plain `<RouteView>`. Auth appears to work because SSR middleware enforces it on first load, but SPA navigations bypass it.
**Why it happens:** The Blazor project template with no auth enabled uses `<RouteView>`. Developers add `[Authorize]` later without switching to `AuthorizeRouteView`.
**How to avoid:** Always use `AuthorizeRouteView` when any page has authorization attributes.
**Warning signs:** Users can navigate to "protected" pages after their session expires, as long as they don't do a full page reload.

### Pitfall 2: Session Key Type Mismatch Between Apps

**What goes wrong:** System.Web Adapters JSON serializer uses the registered type for deserialization. If the legacy app registers `int` but stores a `Guid`, the value may fail to deserialize or produce a default/null value.
**Why it happens:** The session key registration was set up independently on both sides without cross-checking types.
**How to avoid:** Audit both sides' `RegisterKey<T>` calls against the actual types stored in session.
**Warning signs:** Session values appearing as null or default on the Blazor side despite being populated in legacy.

### Pitfall 3: YARP Fallback Triggering Remote Auth

**What goes wrong:** YARP fallback requests to the legacy app trigger remote authentication, causing unnecessary HTTP calls back to the legacy app.
**Why it happens:** Remote auth is the default scheme (`AddAuthenticationClient(true)`), so it runs for all requests.
**How to avoid:** Use `ShortCircuit()` on the YARP fallback route (already done correctly in this project).
**Warning signs:** Slow page loads for legacy pages, circular request patterns.

### Pitfall 4: PersistentComponentState Only Works on Initial Render

**What goes wrong:** Developers try to use `PersistentComponentState` to refresh session data after circuit reconnection.
**Why it happens:** Misunderstanding of the component lifecycle. `TryTakeFromJson` only returns data that was persisted during the preceding SSR render.
**How to avoid:** Accept that session data is a point-in-time snapshot. For refresh, force a full page reload.
**Warning signs:** Null session data after circuit reconnection.

## Code Examples

### Current UserSessionContext.Initialize (reference)

```csharp
// Source: src/SignaturPortal.Web/Services/UserSessionContext.cs
public void Initialize()
{
    if (IsInitialized) return;
    var swSession = System.Web.HttpContext.Current?.Session;
    if (swSession is null) return;
    UserId = swSession["UserId"] is Guid uid ? uid : null;
    SiteId = swSession["SiteId"] is int sid && sid > 0 ? sid : null;
    ClientId = swSession["ClientId"] is int cid && cid > 0 ? cid : null;
    UserName = swSession["UserName"] as string ?? string.Empty;
    UserLanguageId = swSession["UserLanguageId"] is int lid ? lid : 0;
    IsInitialized = true;
}
```

### Corrected Routes.razor (target)

```razor
@using Microsoft.AspNetCore.Components.Authorization

<Router AppAssembly="typeof(Program).Assembly" NotFoundPage="typeof(Pages.NotFound)">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)">
            <NotAuthorized>
                <RedirectToLogin />
            </NotAuthorized>
        </AuthorizeRouteView>
        <FocusOnNavigate RouteData="routeData" Selector="h1" />
    </Found>
</Router>
```

### RedirectToLogin Component (new)

```razor
@inject NavigationManager Navigation

@code {
    protected override void OnInitialized()
    {
        // Redirect to legacy login page with return URL
        // forceLoad: true ensures full HTTP round-trip through YARP
        var currentUri = Uri.EscapeDataString(Navigation.Uri);
        Navigation.NavigateTo($"/Login.aspx?ReturnUrl={currentUri}", forceLoad: true);
    }
}
```

### Program.cs Auth Registration (target)

```csharp
// Add after AddRazorComponents()
builder.Services.AddCascadingAuthenticationState();
```

### Legacy Global.asax.cs Fix (target)

```csharp
// Change from:
options.RegisterKey<int>("UserId");
// To:
options.RegisterKey<Guid>("UserId");
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `<RouteView>` without auth | `<AuthorizeRouteView>` with cascading state | Blazor 6.0+ (2021) | Required for [Authorize] to work in SPA nav |
| Manual cascading auth values | `AddCascadingAuthenticationState()` | .NET 8 (2023) | One-line registration replaces boilerplate |
| Custom AuthenticationStateProvider | System.Web Adapters RemoteAuthenticationAuthHandler | System.Web Adapters 1.0+ | Handles remote auth transparently |

## Open Questions

1. **Legacy login page URL and return URL parameter name**
   - What we know: Legacy uses Forms Authentication with `<forms timeout="480" slidingExpiration="true" />`
   - What's unclear: The exact login page URL (likely `/Login.aspx` but needs verification) and the query parameter name for return URL (ASP.NET Forms Auth uses `ReturnUrl` by default)
   - Recommendation: Check legacy `web.config` for `loginUrl` attribute in `<forms>` element. If not set, ASP.NET defaults to `/Login.aspx`.

2. **What claims does RemoteAuthenticationAuthHandler produce?**
   - What we know: It serializes the legacy `ClaimsPrincipal` and returns it. Forms Auth typically produces a `ClaimsPrincipal` with `Name` claim from the auth cookie.
   - What's unclear: Whether the claims include enough info for the `PermissionHandler` (which uses `IUserSessionContext.UserName`, not claims)
   - Recommendation: This is likely fine because `PermissionHandler` does not use claims -- it uses `IUserSessionContext.UserName`. The remote auth mainly establishes `User.Identity.IsAuthenticated = true` which gates the `[Authorize]` attributes.

3. **Should the Blazor app have a standalone auth mechanism for eventual full cutover?**
   - What we know: Currently 100% dependent on legacy for auth. This is correct for incremental migration.
   - What's unclear: When/whether the legacy app will be fully decommissioned and the Blazor app needs its own login
   - Recommendation: Out of scope for this phase. When the time comes, migrate to ASP.NET Core Identity or cookie auth backed by the same `aspnet_Users` table. For now, remote auth is the correct approach.

## Sources

### Primary (HIGH confidence)
- Microsoft Learn: "Migrate ASP.NET Framework Authentication to ASP.NET Core" - https://learn.microsoft.com/aspnet/core/migration/fx-to-core/areas/authentication?view=aspnetcore-10.0
- Microsoft Learn: "ASP.NET Core Blazor authentication and authorization" - https://learn.microsoft.com/aspnet/core/blazor/security/?view=aspnetcore-10.0
- Codebase: Direct inspection of `Program.cs`, `Routes.razor`, `UserSessionContext.cs`, `SessionPersistence.razor`, `PermissionHandler.cs`, `Global.asax.cs`, `GenericObjects.cs`

### Secondary (MEDIUM confidence)
- System.Web Adapters v2.3.0 behavior inferred from Microsoft docs and working codebase

## Metadata

**Confidence breakdown:**
- Issue identification: HIGH -- all issues verified by direct code inspection against official docs
- Fix recommendations: HIGH -- standard Blazor patterns documented by Microsoft
- Session lifecycle analysis: MEDIUM -- based on understanding of Blazor Server circuit behavior

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (stable patterns, unlikely to change)
