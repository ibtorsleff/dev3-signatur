---
phase: 04-core-write-operations
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/SignaturPortal.Application/Interfaces/IActivityService.cs
  - src/SignaturPortal.Infrastructure/Services/ActivityService.cs
  - src/SignaturPortal.Domain/Interfaces/IRepository.cs
  - src/SignaturPortal.Infrastructure/Repositories/Repository.cs
  - tests/SignaturPortal.Tests/Services/ActivityServiceWriteTests.cs
autonomous: true

must_haves:
  truths:
    - "Service layer creates a new Eractivity entity with correct tenant scoping (ClientId from session)"
    - "Service layer updates an existing activity and catches DbUpdateConcurrencyException"
    - "Service layer soft-deletes an activity by setting status to Deleted (3) after permission check"
    - "All three operations return typed ActivityResult"
    - "Permission checks happen in service layer, not just UI"
  artifacts:
    - path: "src/SignaturPortal.Application/Interfaces/IActivityService.cs"
      provides: "Write method contracts"
      contains: "CreateAsync"
    - path: "src/SignaturPortal.Infrastructure/Services/ActivityService.cs"
      provides: "Write method implementations"
      contains: "CreateAsync"
    - path: "tests/SignaturPortal.Tests/Services/ActivityServiceWriteTests.cs"
      provides: "Unit tests for write operations"
      contains: "CreateAsync"
  key_links:
    - from: "src/SignaturPortal.Infrastructure/Services/ActivityService.cs"
      to: "src/SignaturPortal.Application/DTOs/ActivityResult.cs"
      via: "return ActivityResult.Success/Failure/ConcurrencyConflict"
      pattern: "ActivityResult\\."
    - from: "src/SignaturPortal.Infrastructure/Services/ActivityService.cs"
      to: "src/SignaturPortal.Infrastructure/Data/Entities/Eractivity.cs"
      via: "Repository<Eractivity> for CRUD"
      pattern: "Repository<Eractivity>"
    - from: "src/SignaturPortal.Infrastructure/Services/ActivityService.cs"
      to: "src/SignaturPortal.Application/Interfaces/IPermissionService.cs"
      via: "Permission check before delete"
      pattern: "HasPermissionAsync"
---

<objective>
Implement ActivityService write methods (Create, Update, Delete) with permission checks, concurrency handling, and tenant scoping.

Purpose: The service layer is the core business logic for write operations. It enforces permissions, handles concurrency conflicts via EditedId, and ensures correct tenant scoping. The audit logging (Plan 02) fires automatically via SaveChangesAsync override.

Output: IActivityService with CreateAsync/UpdateAsync/DeleteAsync, implemented ActivityService, unit tests
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-write-operations/04-RESEARCH.md
@.planning/phases/04-core-write-operations/04-01-SUMMARY.md
@.planning/phases/04-core-write-operations/04-02-SUMMARY.md
@src/SignaturPortal.Application/Interfaces/IActivityService.cs
@src/SignaturPortal.Application/Interfaces/IPermissionService.cs
@src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
@src/SignaturPortal.Application/Authorization/ERecruitmentPermission.cs
@src/SignaturPortal.Domain/Interfaces/IRepository.cs
@src/SignaturPortal.Domain/Interfaces/IUnitOfWork.cs
@src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs
@src/SignaturPortal.Infrastructure/Data/Entities/Eractivity.cs
@src/SignaturPortal.Infrastructure/Data/Entities/UserActivityLog.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend IActivityService and implement CreateAsync/UpdateAsync/DeleteAsync</name>
  <files>
    src/SignaturPortal.Application/Interfaces/IActivityService.cs
    src/SignaturPortal.Infrastructure/Services/ActivityService.cs
    src/SignaturPortal.Domain/Interfaces/IRepository.cs
    src/SignaturPortal.Infrastructure/Repositories/Repository.cs
  </files>
  <action>
    1. First, check if IRepository needs a `FindAsync` or queryable method. The current IRepository has GetByIdAsync (takes object id) but no way to query with predicates. For the update flow, we need to load by ID with tracking. GetByIdAsync should work since EF tracks by default. Verify Repository.cs uses FindAsync or FirstOrDefaultAsync with tracking.

    2. Add an `IQueryable<T> Query()` method to IRepository if it doesn't exist:
       ```csharp
       IQueryable<T> Query(); // For complex queries (e.g., checking if journal number is unique)
       ```
       Implement in Repository.cs as `return _context.Set<T>().AsQueryable();`

    3. Extend `IActivityService.cs` with write methods:
       ```csharp
       Task<ActivityResult> CreateAsync(CreateActivityDto dto, CancellationToken ct = default);
       Task<ActivityResult> UpdateAsync(EditActivityDto dto, CancellationToken ct = default);
       Task<ActivityResult> DeleteAsync(int activityId, CancellationToken ct = default);
       Task<EditActivityDto?> GetForEditAsync(int activityId, CancellationToken ct = default);
       ```
       GetForEditAsync returns an EditActivityDto pre-populated with entity data including EditedId, for loading into the edit form.

    4. Implement write methods in `ActivityService.cs` (check if this file already exists from Phase 3 plans -- it may be planned in 03-02 but not yet implemented since Phase 3 is only 1/4 done). If ActivityService.cs doesn't exist yet, create it with the full IActivityService interface. If it exists, add the write methods.

    5. **CreateAsync implementation:**
       ```csharp
       public async Task<ActivityResult> CreateAsync(CreateActivityDto dto, CancellationToken ct)
       {
           await using var uow = _unitOfWorkFactory.Create(); // IUnitOfWork from factory
           var repo = uow.Repository<Eractivity>();

           var entity = new Eractivity
           {
               ClientId = _session.ClientId,
               Headline = dto.Headline,
               Jobtitle = dto.Jobtitle,
               JournalNo = dto.JournalNo,
               ApplicationDeadline = dto.ApplicationDeadline,
               HireDate = dto.HireDate,
               HireDateFreeText = dto.HireDateFreeText,
               ContinuousPosting = dto.ContinuousPosting,
               EmailOnNewCandidate = dto.EmailOnNewCandidate,
               CandidateEvaluationEnabled = dto.CandidateEvaluationEnabled,
               InterviewRounds = dto.InterviewRounds,
               // Set required defaults for non-user-facing fields:
               Responsible = _session.UserGuid,
               CreatedBy = _session.UserGuid,
               EractivityStatusId = 4, // Draft
               EditedId = Guid.NewGuid(),
               CreateDate = DateTime.UtcNow,
               StatusChangedTimeStamp = DateTime.UtcNow,
               // Template IDs default to 0 (required non-nullable ints in schema)
               ErapplicationTemplateId = 0,
               ErletterTemplateReceivedId = 0,
               ErletterTemplateInterviewId = 0,
               ErletterTemplateRejectedId = 0,
               ErnotifyRecruitmentCommitteeId = 0,
               ErletterTemplateRejectedAfterInterviewId = 0,
               ApplicationTemplateLanguage = "3", // Default from schema
               CalendarTypeId = 0,
               LastCandidateId2 = 0,
               JournalNo = dto.JournalNo,
           };

           await repo.AddAsync(entity, ct);
           await uow.SaveChangesAsync(ct);

           return ActivityResult.Success(entity.EractivityId);
       }
       ```

       IMPORTANT: The Eractivity entity has many required non-nullable int fields (template IDs etc.) that have database defaults of 0. Set them to 0 explicitly since EF won't use DB defaults for non-identity columns unless configured with ValueGeneratedOnAdd.

    6. **UpdateAsync implementation:**
       ```csharp
       public async Task<ActivityResult> UpdateAsync(EditActivityDto dto, CancellationToken ct)
       {
           await using var uow = _unitOfWorkFactory.Create();
           var repo = uow.Repository<Eractivity>();
           var entity = await repo.GetByIdAsync(dto.EractivityId, ct);

           if (entity == null)
               return ActivityResult.NotFound();

           // Map DTO fields to entity
           entity.Headline = dto.Headline;
           entity.Jobtitle = dto.Jobtitle;
           entity.JournalNo = dto.JournalNo;
           entity.ApplicationDeadline = dto.ApplicationDeadline;
           entity.HireDate = dto.HireDate;
           entity.HireDateFreeText = dto.HireDateFreeText;
           entity.ContinuousPosting = dto.ContinuousPosting;
           entity.EmailOnNewCandidate = dto.EmailOnNewCandidate;
           entity.CandidateEvaluationEnabled = dto.CandidateEvaluationEnabled;
           entity.InterviewRounds = dto.InterviewRounds;
           // EditedId will be refreshed to new Guid by SaveChangesAsync override

           // Set the original EditedId for concurrency check
           uow.SetOriginalValue(entity, e => e.EditedId, dto.EditedId);

           try
           {
               await uow.SaveChangesAsync(ct);
               return ActivityResult.Success(entity.EractivityId);
           }
           catch (DbUpdateConcurrencyException)
           {
               return ActivityResult.ConcurrencyConflict(
                   "This activity was modified by another user. Please reload and try again.");
           }
       }
       ```

       NOTE: Setting the original concurrency token value requires access to the DbContext ChangeTracker. Add a method to IUnitOfWork:
       ```csharp
       void SetOriginalValue<TEntity, TProperty>(TEntity entity,
           Expression<Func<TEntity, TProperty>> property, TProperty value)
           where TEntity : class;
       ```
       Implement in UnitOfWork:
       ```csharp
       public void SetOriginalValue<TEntity, TProperty>(TEntity entity,
           Expression<Func<TEntity, TProperty>> property, TProperty value)
           where TEntity : class
       {
           _context.Entry(entity).Property(property).OriginalValue = value;
       }
       ```
       This is needed because when we load the entity fresh (GetByIdAsync), its EditedId is the current DB value. But we need EF to think the original value is the one from when the user started editing (dto.EditedId), so the WHERE clause checks against that.

       ACTUALLY: Simpler approach -- after loading, set the entity's EditedId to the DTO's EditedId, then let the SaveChangesAsync override refresh it. But that defeats the concurrency check because OriginalValue would still be the DB's current value. The SetOriginalValue approach is correct.

       Add SetOriginalValue to IUnitOfWork and UnitOfWork.

    7. **DeleteAsync implementation:**
       Soft-delete by setting EractivityStatusId = 3 (Deleted), NOT hard-delete. The legacy app uses status-based deletion:
       ```csharp
       public async Task<ActivityResult> DeleteAsync(int activityId, CancellationToken ct)
       {
           // Permission check in service layer (not just UI)
           var hasPermission = await _permissionService.HasPermissionAsync(
               _session.UserName, (int)ERecruitmentPermission.DeleteActivity, ct);
           if (!hasPermission)
               return ActivityResult.PermissionDenied();

           await using var uow = _unitOfWorkFactory.Create();
           var repo = uow.Repository<Eractivity>();
           var entity = await repo.GetByIdAsync(activityId, ct);

           if (entity == null)
               return ActivityResult.NotFound();

           entity.EractivityStatusId = 3; // Deleted status
           entity.StatusChangedTimeStamp = DateTime.UtcNow;

           await uow.SaveChangesAsync(ct);
           return ActivityResult.Success(activityId);
       }
       ```

    8. **GetForEditAsync implementation:**
       ```csharp
       public async Task<EditActivityDto?> GetForEditAsync(int activityId, CancellationToken ct)
       {
           await using var uow = _unitOfWorkFactory.Create();
           var repo = uow.Repository<Eractivity>();
           var entity = await repo.GetByIdAsync(activityId, ct);
           if (entity == null) return null;

           return new EditActivityDto
           {
               EractivityId = entity.EractivityId,
               EditedId = entity.EditedId,
               Headline = entity.Headline,
               Jobtitle = entity.Jobtitle,
               JournalNo = entity.JournalNo,
               ApplicationDeadline = entity.ApplicationDeadline,
               HireDate = entity.HireDate,
               HireDateFreeText = entity.HireDateFreeText,
               ContinuousPosting = entity.ContinuousPosting,
               EmailOnNewCandidate = entity.EmailOnNewCandidate,
               CandidateEvaluationEnabled = entity.CandidateEvaluationEnabled,
               InterviewRounds = entity.InterviewRounds,
           };
       }
       ```

    9. **Service constructor dependencies:**
       ActivityService needs: IDbContextFactory<SignaturDbContext> (to create UoW), IUserSessionContext, IPermissionService.
       BUT: The current pattern creates UoW inside service methods. Check if there's a UoW factory or if services create UoW directly. If UnitOfWork constructor takes IDbContextFactory + IUserSessionContext, the service needs both to create UoW instances per operation.

       Simplest approach: Inject IDbContextFactory<SignaturDbContext> and IUserSessionContext, create UnitOfWork inline. This avoids adding a factory abstraction. Import UnitOfWork directly (Infrastructure references are fine in Infrastructure layer where ActivityService lives).

    10. Register ActivityService in DI (Program.cs or wherever services are registered). Check existing pattern.
  </action>
  <verify>
    `dotnet build src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj` compiles.
    `dotnet build src/SignaturPortal.Web/SignaturPortal.Web.csproj` compiles.
    Verify IActivityService has CreateAsync, UpdateAsync, DeleteAsync, GetForEditAsync methods.
    Verify ActivityService.cs implements all four methods.
  </verify>
  <done>
    ActivityService has CreateAsync (tenant-scoped, Draft status), UpdateAsync (concurrency via EditedId), DeleteAsync (soft-delete with permission check), and GetForEditAsync. All return ActivityResult. IUnitOfWork has SetOriginalValue for concurrency token manipulation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for ActivityService write operations</name>
  <files>
    tests/SignaturPortal.Tests/Services/ActivityServiceWriteTests.cs
  </files>
  <action>
    1. Check existing test structure and patterns:
       ```bash
       ls tests/SignaturPortal.Tests/
       ```
       Follow existing test patterns (TUnit framework).

    2. Create `Services/ActivityServiceWriteTests.cs` with tests for:

       **CreateAsync tests:**
       - Test_CreateAsync_SetsClientIdFromSession: Verify entity.ClientId == session.ClientId
       - Test_CreateAsync_SetsStatusToDraft: Verify EractivityStatusId == 4
       - Test_CreateAsync_ReturnsSuccessWithId: Verify result.IsSuccess and result.ActivityId > 0

       **UpdateAsync tests:**
       - Test_UpdateAsync_ReturnsNotFound_WhenActivityMissing
       - Test_UpdateAsync_ReturnsConcurrencyConflict_WhenEditedIdMismatch: Set up entity with different EditedId than DTO, expect ConcurrencyConflict result
       - Test_UpdateAsync_ReturnsSuccess_WhenNoConflict

       **DeleteAsync tests:**
       - Test_DeleteAsync_ReturnsPermissionDenied_WhenNoPermission: Mock IPermissionService returning false
       - Test_DeleteAsync_SoftDeletes_SetStatusToDeleted: Verify EractivityStatusId changed to 3
       - Test_DeleteAsync_ReturnsNotFound_WhenActivityMissing

       3. Use mocks for IDbContextFactory, IUserSessionContext, IPermissionService. Since ActivityService creates UnitOfWork internally, the tests may need to use a real in-memory DbContext or mock at a higher level.

       APPROACH: Since UnitOfWork is created inside methods using IDbContextFactory, use an in-memory SQLite or InMemoryDatabase provider for tests. Set up the DbContext with test data.

       If the test project already uses a specific pattern (check existing test files), follow that pattern.

       Keep tests focused -- 8-10 test methods covering the critical paths.
  </action>
  <verify>
    `dotnet test tests/SignaturPortal.Tests/ --filter "ActivityServiceWrite"` runs and tests pass.
    If in-memory provider has issues with concurrency tokens, document the limitation and ensure at least the non-concurrency tests pass.
  </verify>
  <done>
    Unit tests cover create (tenant scoping, draft status), update (not found, concurrency conflict, success), and delete (permission denied, soft delete, not found). Tests run green.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for all projects
- `dotnet test` passes for ActivityServiceWriteTests
- IActivityService has 4 new methods (Create, Update, Delete, GetForEdit)
- ActivityService implements all 4 with proper error handling
- Concurrency conflict returns ConcurrencyConflict result (not exception)
- Delete is soft-delete (status = 3), not hard delete
- Permission check in DeleteAsync uses IPermissionService
- SetOriginalValue added to IUnitOfWork for concurrency token manipulation
</verification>

<success_criteria>
ActivityService write methods are fully implemented and tested. Create scopes to tenant, Update handles concurrency, Delete checks permissions and soft-deletes. Audit logging fires automatically via SaveChangesAsync override from Plan 02.
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-write-operations/04-03-SUMMARY.md`
</output>
