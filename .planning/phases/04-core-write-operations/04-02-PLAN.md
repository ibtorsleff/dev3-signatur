---
phase: 04-core-write-operations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
  - src/SignaturPortal.Infrastructure/Data/AuditEntry.cs
  - src/SignaturPortal.Infrastructure/Data/AuditableDbContext.cs
  - src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs
  - src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
autonomous: true

must_haves:
  truths:
    - "EditedId on Eractivity is configured as EF Core concurrency token"
    - "SaveChangesAsync creates UserActivityLog entries for tracked entity changes"
    - "Audit logging does not cause infinite recursion"
    - "UnitOfWork exposes the user's Guid (aspnet_Users.UserId) for audit logging"
  artifacts:
    - path: "src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs"
      provides: "Concurrency token config + SaveChanges audit override"
      contains: "IsConcurrencyToken"
    - path: "src/SignaturPortal.Infrastructure/Data/AuditEntry.cs"
      provides: "Temporary audit entry model for change tracking"
      contains: "class AuditEntry"
  key_links:
    - from: "src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs"
      to: "src/SignaturPortal.Infrastructure/Data/Entities/UserActivityLog.cs"
      via: "UserActivityLogs.Add in AfterSaveChanges"
      pattern: "UserActivityLogs\\.Add"
    - from: "src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs"
      to: "src/SignaturPortal.Infrastructure/Data/Entities/Eractivity.cs"
      via: "IsConcurrencyToken on EditedId"
      pattern: "IsConcurrencyToken"
---

<objective>
Add concurrency token configuration for Eractivity.EditedId and implement audit logging via SaveChangesAsync override.

Purpose: These infrastructure concerns (concurrency detection, audit trail) must be in place before any write operations execute. Both are cross-cutting and apply to all CUD operations.

Output: Concurrency token configured, audit logging intercepting all saves, UserSessionContext extended with UserGuid
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-write-operations/04-RESEARCH.md
@src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
@src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
@src/SignaturPortal.Infrastructure/Data/Entities/Eractivity.cs
@src/SignaturPortal.Infrastructure/Data/Entities/UserActivityLog.cs
@src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs
@src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
@src/SignaturPortal.Web/Services/UserSessionContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure EditedId as concurrency token and extend IUserSessionContext with UserGuid</name>
  <files>
    src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
    src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
    src/SignaturPortal.Web/Services/UserSessionContext.cs
  </files>
  <action>
    1. In `SignaturDbContext.Custom.cs`, inside the existing `OnModelCreatingPartial` method, add concurrency token configuration for Eractivity.EditedId:
       ```csharp
       modelBuilder.Entity<Eractivity>()
           .Property(e => e.EditedId)
           .IsConcurrencyToken();
       ```
       This tells EF Core to include EditedId in the WHERE clause of UPDATE statements. When an edit starts, the current EditedId is captured. On save, if another user changed the row (and thus EditedId changed), DbUpdateConcurrencyException is thrown.

       IMPORTANT: The Eractivity entity already has `.HasQueryFilter()` configured in this same partial method. Add the concurrency token config BEFORE the query filter section, as a separate `modelBuilder.Entity<Eractivity>()` call. EF Core merges multiple configurations for the same entity.

    2. Add `UserGuid` property to `IUserSessionContext`:
       ```csharp
       Guid UserGuid { get; }
       ```
       The UserActivityLog.ActionUserId is a Guid (aspnet_Users.UserId), but the current IUserSessionContext.UserId is an int (session hash). The audit logger needs the actual Guid.

       CRITICAL: The session key "UserId" stores `aUser.UserId.GetHashCode()` which is an int hash, NOT the actual Guid. To get the actual Guid, the UserSessionContext implementation needs to look up the aspnet_Users table by UserName (which IS available in session). Add this lookup.

    3. Update `UserSessionContext.cs` (the Web layer implementation) to add `UserGuid`:
       - Add a `Guid UserGuid { get; private set; }` property
       - In the initialization path (where session values are read in OnInitialized), after getting UserName from session, query aspnet_Users to get the actual UserId Guid:
         ```csharp
         // After reading UserName from session:
         await using var uow = _unitOfWorkFactory.Create(); // or use IDbContextFactory directly
         var user = await dbContext.AspnetUsers
             .Where(u => u.UserName == UserName)
             .Select(u => u.UserId)
             .FirstOrDefaultAsync();
         UserGuid = user;
         ```
       - If UserSessionContext doesn't have access to DbContext, inject IDbContextFactory<SignaturDbContext> and do the lookup there. Check the current implementation first.

       NOTE: If injecting DbContext into UserSessionContext creates a circular dependency or architectural concern (scoped service depending on DbContext factory), an alternative approach is to store UserGuid resolution in a lazy property that resolves on first access. However, since UserSessionContext is already initialized during SSR (OnInitialized), doing the lookup there is the cleanest approach.
  </action>
  <verify>
    `dotnet build src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj` and `dotnet build src/SignaturPortal.Web/SignaturPortal.Web.csproj` both compile.
  </verify>
  <done>
    EditedId is configured as IsConcurrencyToken. IUserSessionContext has UserGuid property. UserSessionContext resolves the Guid from aspnet_Users by UserName during SSR initialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement audit logging via SaveChangesAsync override</name>
  <files>
    src/SignaturPortal.Infrastructure/Data/AuditEntry.cs
    src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
    src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs
  </files>
  <action>
    1. Create `AuditEntry.cs` in the Data folder -- a simple internal class to hold change tracking data between BeforeSaveChanges and AfterSaveChanges:
       ```csharp
       internal class AuditEntry
       {
           public string EntityTypeName { get; set; } = "";
           public int? EntityTypeId { get; set; }
           public int? EntityId { get; set; }
           public string Action { get; set; } = ""; // "Created", "Modified", "Deleted"
           public DateTime Timestamp { get; set; }
       }
       ```
       EntityTypeId mapping (for UserActivityLog.EntityTypeId):
       - Eractivity = 1 (or whatever value the legacy app uses -- check legacy code if possible, otherwise use 1)
       - Ercandidate = 2
       - Other entities = null (log them but without type ID)

    2. In `SignaturDbContext.Custom.cs`, add a property to hold the current user Guid for audit purposes:
       ```csharp
       public Guid? AuditUserId { get; set; }
       ```

    3. Override `SaveChangesAsync` in the Custom partial class:
       ```csharp
       public override async Task<int> SaveChangesAsync(CancellationToken ct = default)
       {
           // Update EditedId for any modified Eractivity entities (concurrency token refresh)
           foreach (var entry in ChangeTracker.Entries<Eractivity>()
               .Where(e => e.State == EntityState.Modified))
           {
               entry.Entity.EditedId = Guid.NewGuid();
           }

           var auditEntries = BeforeSaveChanges();
           var result = await base.SaveChangesAsync(ct);

           if (auditEntries.Count > 0 && AuditUserId.HasValue)
           {
               await AfterSaveChanges(auditEntries, ct);
           }

           return result;
       }
       ```

       CRITICAL anti-infinite-loop: AfterSaveChanges calls `base.SaveChangesAsync()` (not the overridden method). This is already the correct pattern since the override calls base. But to be extra safe, use a `_isSavingAudit` boolean flag:
       ```csharp
       private bool _isSavingAudit;

       public override async Task<int> SaveChangesAsync(CancellationToken ct = default)
       {
           if (_isSavingAudit) return await base.SaveChangesAsync(ct);
           // ... rest of audit logic
       }
       ```

    4. Implement `BeforeSaveChanges()`:
       - Iterate ChangeTracker.Entries() where State is Added, Modified, or Deleted
       - Skip UserActivityLog entities (don't audit the audit log)
       - For each entry, create an AuditEntry with:
         - EntityTypeName = entry.Entity.GetType().Name
         - EntityId = try to get the PK value from entry (entry.Properties.First(p => p.Metadata.IsPrimaryKey()).CurrentValue as int?)
         - Action = entry.State switch { Added => "Created", Modified => "Modified", Deleted => "Deleted" }
         - Timestamp = DateTime.UtcNow
       - Return List<AuditEntry>

    5. Implement `AfterSaveChanges()`:
       - For each AuditEntry, create a UserActivityLog entity:
         ```csharp
         new UserActivityLog
         {
             ActionUserId = AuditUserId!.Value,
             EntityTypeId = auditEntry.EntityTypeId,
             EntityId = auditEntry.EntityId,
             TimeStamp = auditEntry.Timestamp,
             Log = $"{auditEntry.Action}: {auditEntry.EntityTypeName} (ID: {auditEntry.EntityId})"
         }
         ```
       - Add all to UserActivityLogs DbSet
       - Set _isSavingAudit = true, call base.SaveChangesAsync(ct), set _isSavingAudit = false

    6. Update `UnitOfWork.cs` to stamp AuditUserId on the DbContext:
       ```csharp
       public UnitOfWork(IDbContextFactory<SignaturDbContext> contextFactory, IUserSessionContext session)
       {
           _context = contextFactory.CreateDbContext();
           if (session.IsInitialized)
           {
               _context.CurrentSiteId = session.SiteId;
               _context.CurrentClientId = session.ClientId;
               _context.AuditUserId = session.UserGuid;  // NEW
           }
       }
       ```
  </action>
  <verify>
    `dotnet build src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj` compiles with no errors.
    Verify SaveChangesAsync override exists in Custom partial and calls base.SaveChangesAsync.
    Verify _isSavingAudit guard prevents infinite recursion.
  </verify>
  <done>
    SaveChangesAsync override intercepts all CUD operations, creates UserActivityLog entries, and avoids infinite recursion. EditedId is refreshed with a new Guid on every Eractivity modification. AuditUserId flows from UnitOfWork through session context.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for Infrastructure and Web projects
- EditedId configured as IsConcurrencyToken in OnModelCreatingPartial
- SaveChangesAsync override creates UserActivityLog entries
- _isSavingAudit flag prevents infinite loop
- UnitOfWork stamps AuditUserId from session
- IUserSessionContext has UserGuid property
</verification>

<success_criteria>
Infrastructure layer has concurrency detection (EditedId token) and automatic audit logging (SaveChanges override) ready for all write operations. Any SaveChangesAsync call automatically creates UserActivityLog entries.
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-write-operations/04-02-SUMMARY.md`
</output>
