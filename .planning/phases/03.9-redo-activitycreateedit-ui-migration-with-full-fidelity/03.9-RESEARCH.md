# Phase 03.9: Redo ActivityCreateEdit UI Migration with Full Fidelity - Research

**Researched:** 2026-02-23
**Domain:** Blazor Server form migration, MudBlazor component patterns, EF Core entity mapping, legacy ASPX parity
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Rewrite scope:** ActivityCreateEdit.razor, ActivityCreateEdit.razor.cs, ActivityCreateEdit.razor.css — all three from scratch
**Keep as-is:** All DTOs (ActivityFormModel, ActivityFormOptionsDto, ActivityClientConfigDto, ActivitySaveCommand, ActivityEditDto) and all service implementations in ErActivityService and ClientService
**Blueprint:** Follow `.planning/research/ActivityCreateEditMigration.md` exactly as the implementation spec
**All controls must be migrated:** Every field, business rule, and localization key from legacy — no omissions
**Legacy component sequence:** Field order and grouping must match the legacy ASPX page exactly
**Responsive layout:** Labels and inputs render side-by-side at wider screens, stacked on mobile — matching the legacy two-rendering approach (MudGrid MudItem xs/md breakpoints)

**Missing DB Fields:**
- RecruitmentTypeId — REQUIRED field. Researcher must audit legacy DB schema and ASPX code. (See findings below)
- ClosedCalendarEnabled / OpenCalendarEnabled — Researcher audits DB. If no real columns, keep UI checkboxes but mark non-persisting. (See findings below)
- LeadershipPositions / BlindRecruitmentOptions — Hardcoded "Ja"/"Nej" acceptable for this phase.

**Template Cascade:**
- Client change cascade: Reloads all client-dependent options. Show visible loading/disabled state on affected fields.
- Template group change: Only reloads ApplicationTemplates (not email/SMS lists).
- Email and SMS template lists are NOT filtered by template group. Only application templates are filtered.

**Save / Navigation:**
- After save (edit mode): Navigate to `/recruiting/activities` (activity list). Do NOT stay on the edit page.
- After save (create mode): Navigate to `/recruiting/activities/{newId}/edit`.
- After Delete: Navigate to `/recruiting/activities`.
- After Close Activity: Navigate to `/recruiting/activities`.
- Cancel (edit mode): Navigate to `/recruiting/activities/{id}` (activity detail).
- Cancel (create mode): Navigate to `/recruiting/activities`.

**Validation Messages:**
- Cross-field validation errors must use DB localization keys via `GetText()` — not hardcoded English.
- Correct legacy localization keys for all validation error messages must be identified.
- `IValidatableObject.Validate()` should use ILocalizationService for error text.

### Claude's Discretion
- Loading skeleton vs. progress linear during initial page load
- Exact CSS class names and spacing values (follow existing ActivityList patterns)
- Whether to use `MudPaper` or `MudCard` for section containers (research doc uses MudCard)
- Error state design for server-side EAN validation alert

### Deferred Ideas (OUT OF SCOPE)
- Localization of LeadershipPosition and BlindRecruitment dropdown labels (Ja/Nej) — future phase
- ClosedCalendarEnabled / OpenCalendarEnabled full persistence — pending DB audit; if columns don't exist this is a follow-up phase
- Info/help tooltips (ⓘ icons with *Info/*InfoFund localization keys) — not explicitly requested for this phase
</user_constraints>

---

## Summary

Phase 03.9 is a full rewrite of the three ActivityCreateEdit files (.razor, .razor.cs, .razor.css) to correct a wrong initial UI start. The services, DTOs, and supporting infrastructure are already fully implemented and correct — they do not need modification. The rewrite focuses entirely on the Blazor presentation layer.

The existing implementation is structurally close to correct but has several identified defects: wrong post-save navigation (stays on page instead of navigating to list after edit), the `RecruitmentTypeId` field on the form does NOT map to a real `RecruitmentTypeId` column on the `Eractivity` entity — instead, the legacy system stores recruitment type via two boolean columns `IsLeadershipPosition` and `IsBlindRecruitment`, and the service already handles this translation correctly. The "RecruitmentType" dropdown (`ERRecruitmentType` table) in the current implementation is a UI-level convenience that maps to these booleans on save. The `ClosedCalendarEnabled`/`OpenCalendarEnabled` fields in the form model do NOT map to real DB columns — the DB stores a single `CalendarTypeId` (0=NoCalendar, 1=OpenCalendar, 2=ClosedCalendar). The current implementation has diverged from the spec in this area.

**Primary recommendation:** The rewrite should be a clean copy of the existing files' structure, correcting the identified defects (navigation, RecruitmentType data model clarification, CalendarType vs ClosedCalendar/OpenCalendar divergence, validation messages, and cascade loading states). The research spec in `ActivityCreateEditMigration.md` is the authoritative field order and business rule guide.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| MudBlazor | 8.x (installed) | Form controls, dialogs, layout | Project standard — all pages use it |
| Microsoft.AspNetCore.Components | .NET 10 | EditForm, DataAnnotationsValidator, IValidatableObject | Blazor built-in |
| System.ComponentModel.DataAnnotations | .NET 10 | [Required], [MaxLength], ValidationResult | Cross-field validation via IValidatableObject |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| ILocalizationService | project | DB-backed GetText() translations | Every label and error message |
| IErActivityService | project | Form data load, save, delete, close | All form operations |
| IClientService | project | Client config flags, client list | Client-dependent visibility |
| ICurrentUserService | project | DB-backed current user (IsInternal, UserId) | Permission checks, audit |
| IUserSessionContext | project | Session SiteId, ClientId | Client pre-selection on create |
| IDialogService | MudBlazor | UserPickerDialog, confirm dialogs | User picker and Delete/Close confirm |
| ISnackbar | MudBlazor | (Not used — see navigation decisions) | Only if needed for non-navigating success |

### Already-Written Infrastructure (Do Not Rebuild)
- `ActivityFormModel.cs` — mutable form model with IValidatableObject
- `ActivityFormOptionsDto.cs` — all dropdown lists + SimpleOptionDto + ActivityStatusOptionDto
- `ActivityClientConfigDto.cs` — 11 client feature flags
- `ActivitySaveCommand.cs` — write command
- `ActivityEditDto.cs` — edit mode pre-population DTO
- `UserPickerDialog.razor` + `.razor.cs` — user search/select dialog (complete)
- All `IErActivityService` + `IClientService` method signatures and implementations

---

## Architecture Patterns

### Recommended Project Structure (existing — unchanged)
```
src/SignaturPortal.Web/Components/Pages/Recruiting/
├── ActivityCreateEdit.razor         ← REWRITE (UI markup)
├── ActivityCreateEdit.razor.cs      ← REWRITE (code-behind)
└── ActivityCreateEdit.razor.css     ← REWRITE (scoped styles)

src/SignaturPortal.Web/Components/Shared/Recruiting/
├── UserPickerDialog.razor           ← Keep as-is
└── UserPickerDialog.razor.cs        ← Keep as-is
```

### Pattern 1: Code-Behind Partial Class
**What:** Logic in `.razor.cs` partial class, markup in `.razor` file
**When to use:** All pages in this project — established convention since Phase 03-02
**Example:**
```csharp
// ActivityCreateEdit.razor.cs
public partial class ActivityCreateEdit
{
    [Parameter] public int? ActivityId { get; set; }
    [SupplyParameterFromQuery] public int? ClientId { get; set; }
    // ...
}
```

### Pattern 2: Explicit External Labels (Not MudBlazor Floating Labels)
**What:** `<label class="field-label-text">` before each input, NOT Label= parameter on MudBlazor components
**Why:** Matches legacy ASPX layout, side-by-side on desktop, stacked on mobile
**Key:** MudSelect label-gap mismatch — always inject this fix:
```razor
<HeadContent>
    <style>
        .activity-form .mud-input-control { margin-top: 0 !important; }
    </style>
</HeadContent>
```
This normalizes all inputs (MudSelect, MudAutocomplete, MudTextField) to the same 4px gap from their external label. **Source: project MEMORY.md — verified fix.**

### Pattern 3: Form-Field Div Wrapper
**What:** Each label+input pair wrapped in `<div class="form-field">`
**When to use:** All non-checkbox fields
```razor
<div class="form-field">
    <label class="field-label-text">@Localization.GetText("Headline") <span class="required-mark">*</span></label>
    <MudTextField ... />
    <ValidationMessage For="@(() => _form.Headline)" />
</div>
```

### Pattern 4: Checkbox Wrapper
**What:** Checkbox in `<div class="form-field form-field-checkbox">` with `<span class="checkbox-label-text">`
**When to use:** All boolean fields (MudCheckBox)
```razor
<div class="form-field form-field-checkbox">
    <MudCheckBox T="bool" @bind-Value="_form.Reposting" Dense="true">
        <span class="checkbox-label-text">@Localization.GetText("Reposting")</span>
    </MudCheckBox>
</div>
```

### Pattern 5: Async Cascade with Loading State
**What:** Show `_cascadeLoading` flag that disables affected fields during async reload
**When to use:** Client change cascade (all client-dependent fields disabled while reloading)
**Example:**
```csharp
private bool _cascadeLoading;

private async Task OnClientChangedAsync(ClientDropdownDto? client)
{
    _cascadeLoading = true;
    StateHasChanged();
    // ... reload ...
    _cascadeLoading = false;
}
```
In markup: `Disabled="@(_cascadeLoading || !_form.ClientId.HasValue)"`

### Pattern 6: IValidatableObject with ILocalizationService
**What:** Cross-field validation calls localization service for error messages
**Challenge:** `IValidatableObject.Validate(ValidationContext)` — services must be injected via ValidationContext
**Approach:** Store localization service reference in a field, call it from Validate()
```csharp
// Option A: Set on model before validation (in OnSaveAsync)
_form.LocalizationService = Localization;

// Option B: Read from ValidationContext.GetService<ILocalizationService>()
public IEnumerable<ValidationResult> Validate(ValidationContext context)
{
    var loc = context.GetService<ILocalizationService>();
    // ...
}
```
Note: ValidationContext.GetService is only populated when registered in DI container and passed correctly by EditForm. Blazor's DataAnnotationsValidator does populate it from the component's service provider. **Source: .NET docs — HIGH confidence.**

### Anti-Patterns to Avoid
- **Using `NavigateTo` with `forceLoad: true`:** Only for YARP-proxied legacy URLs (Manage Committee, Interview Schedule). Blazor-side navigations use default `forceLoad: false`.
- **Using Label= on MudSelect/MudAutocomplete:** Causes floating label layout — use explicit `<label>` elements instead.
- **Setting `_saving = false` in the success path of navigation:** Navigation fires immediately — no need to reset since component is destroyed.

---

## Critical Findings: Data Model Divergences

### Finding 1: RecruitmentTypeId Does NOT Exist on Eractivity Entity (HIGH confidence)

**Verified by reading:** `src/SignaturPortal.Infrastructure/Data/Entities/Eractivity.cs`

The `Eractivity` DB entity has NO `RecruitmentTypeId` column. Instead, it has:
- `IsLeadershipPosition bool?`
- `IsBlindRecruitment bool?`

The `ERRecruitmentType` table (used by the current implementation) exists in the DB as a lookup table, but the `Eractivity` entity does not have a FK to it.

**How legacy maps it:** The legacy `RecruitmentTypeEn` enum:
```
Undefined = 0, Normal = 1, LeadershipPosition = 2, BlindRecruitment = 3
```
On save, the `recruitmentType` dropdown selection maps:
- `LeadershipPosition` → `er.IsLeadershipPosition = true`
- `BlindRecruitment` → `er.IsBlindRecruitment = true`
- `Normal` → both `false`

**How the service already handles this:**
- `GetActivityForEditAsync` maps `IsLeadershipPosition bool?` → `LeadershipPositionId int?` (1=Yes, 2=No, null=not set)
- `GetActivityFormOptionsAsync` returns hardcoded `LeadershipPositions = [{Id:1, "Ja"}, {Id:2, "Nej"}]` and `BlindRecruitmentOptions = [{Id:1, "Ja"}, {Id:2, "Nej"}]`
- `MapCommandToEntity` maps `LeadershipPositionId==1 → IsLeadershipPosition=true` etc.

**Additionally:** `GetActivityFormOptionsAsync` also queries `ERRecruitmentType` and returns `RecruitmentTypes`. The form model has `RecruitmentTypeId`. The existing razor UI shows both a RecruitmentType dropdown AND separate LeadershipPosition and BlindRecruitment selects — but this is a UI error introduced in the wrong implementation.

**Correct implementation for this phase (per CONTEXT.md decision):**
The `RecruitmentTypeId` field in the form model correctly represents the UI dropdown that maps to IsLeadershipPosition/IsBlindRecruitment. The ERRecruitmentType lookup table is the source for display names. The `MapCommandToEntity` would need to handle the RecruitmentTypeId → IsLeadershipPosition/IsBlindRecruitment translation.

**Current service gap:** `MapCommandToEntity` currently maps `command.LeadershipPositionId` and `command.BlindRecruitmentId` separately but the `ActivitySaveCommand` has no `RecruitmentTypeId` field. The rewrite of the UI should drive `RecruitmentTypeId` on the form model and propagate it to the command. This requires:
1. Adding `RecruitmentTypeId` to `ActivitySaveCommand` (or re-using existing `LeadershipPositionId`/`BlindRecruitmentId`)
2. Updating `MapCommandToEntity` to handle the combined enum

Actually, reading the CONTEXT.md decision again: "Keep as-is: All DTOs." This means `ActivitySaveCommand` is kept as-is with `LeadershipPositionId` and `BlindRecruitmentId`. The UI form model already has `RecruitmentTypeId`, but `ActivitySaveCommand` does not. The `BuildSaveCommand()` in the code-behind must translate form `RecruitmentTypeId` → `LeadershipPositionId` + `BlindRecruitmentId` on the command.

**Translation table:**
| RecruitmentTypeId (form/ERRecruitmentType.ERRecruitmentTypeId) | LeadershipPositionId | BlindRecruitmentId |
|---|---|---|
| 1 (Normal) | 2 (No) | 2 (No) |
| 2 (LeadershipPosition) | 1 (Yes) | 2 (No) |
| 3 (BlindRecruitment) | 2 (No) | 1 (Yes) |
| null | null | null |

**Also:** `GetActivityForEditAsync` returns `LeadershipPositionId` + `BlindRecruitmentId` — the code-behind must translate these back to a single `RecruitmentTypeId` when mapping edit data to the form model.

### Finding 2: ClosedCalendarEnabled / OpenCalendarEnabled Do NOT Map to DB Columns (HIGH confidence)

**Verified by reading:** `src/SignaturPortal.Infrastructure/Data/Entities/Eractivity.cs` and legacy ASPX source

The `Eractivity` entity has a single `CalendarTypeId int` column (mapped from `er.CalendarType` in legacy, an `ERCalendarType` enum). There are NO `ClosedCalendarEnabled` or `OpenCalendarEnabled` boolean columns on the entity.

The legacy UI has a single `calendarType` dropdown (ERCalendarType enum: 0=NoCalendarFunction, 1=OpenCalendar, 2=ClosedCalendar). The `closedCalendarEnabled` and `openCalendarEnabled` checkboxes shown in the legacy UI are actually client-feature flags (`ClientHlp.ClientRecruitmentClosedCalendarEnabled` / `ClientHlp.ClientRecruitmentOpenCalendarEnabled`), NOT per-activity settings.

**Per CONTEXT.md decision:** "If these don't map to real DB columns, keep the UI checkboxes but mark them as non-persisting (read-only state, known gap)."

**Service already handles this:** `MapCommandToEntity` maps `command.CalendarTypeId ?? 0` → `entity.CalendarTypeId`. The `ClosedCalendarEnabled` and `OpenCalendarEnabled` on `ActivitySaveCommand` are currently not mapped to the entity (they're in the command record but `MapCommandToEntity` ignores them).

**Correct approach for this phase:**
- Keep `ClosedCalendarEnabled` and `OpenCalendarEnabled` on the form model as non-persisting UI-only state
- When loading for edit: derive them from `CalendarTypeId`: ClosedCalendarEnabled = (CalendarTypeId == 2), OpenCalendarEnabled = (CalendarTypeId == 1)
- They control visibility (e.g., show InterviewDuration if OpenCalendarEnabled)
- Save only `CalendarTypeId` — driven by the calendar type dropdown or derived from checkbox state
- The current form model stores these separately which is acceptable as UI-only state

**Mapping to derive from CalendarTypeId on load:**
```csharp
_form.ClosedCalendarEnabled = _editData.CalendarTypeId == 2;
_form.OpenCalendarEnabled = _editData.CalendarTypeId == 1;
```
When saving: derive CalendarTypeId from the checkbox state:
```csharp
CalendarTypeId = _form.ClosedCalendarEnabled ? 2 :
                 _form.OpenCalendarEnabled ? 1 : 0
```

Wait — this is a UX mismatch. The legacy has a single dropdown for CalendarType, not checkboxes for each. The research spec (`ActivityCreateEditMigration.md`) describes UI checkboxes for ClosedCalendar and OpenCalendar with a CalendarType dropdown appearing only when both are checked.

**Keeping the current form model approach is consistent** with the research spec, accepting that ClosedCalendar/OpenCalendar are non-persisting beyond being derived from CalendarTypeId. The save command already has these fields and `MapCommandToEntity` already reads `CalendarTypeId` from the command — just ensure the command's `CalendarTypeId` is set from the derived checkbox state.

### Finding 3: Missing Navigate-Away After Edit Save (HIGH confidence)

**Verified by reading:** `ActivityCreateEdit.razor.cs` lines 414-443

Current code:
```csharp
await ErActivityService.UpdateActivityAsync(ActivityId.Value, command);
Snackbar.Add(Localization.GetText("SavedSuccessfully"), Severity.Success);
// No navigation — stays on page (WRONG)
```

Required (from CONTEXT.md):
```csharp
await ErActivityService.UpdateActivityAsync(ActivityId.Value, command);
Navigation.NavigateTo("/recruiting/activities");
```

### Finding 4: Validation Messages Are Hardcoded English (HIGH confidence)

**Verified by reading:** `ActivityFormModel.cs` lines 131-153

Current hardcoded strings:
```csharp
"Application deadline is required when continuous posting is not enabled."
"Hire date is required."
"Hire date must be on or after the application deadline."
"Hire date text is required."
```

Required localization keys from legacy ASPX (confirmed by searching `ActivityCreateEdit.aspx.cs`):
- Deadline required: `"ApplicationDeadlineMandatory"` or equivalent — need to identify exact key
- Hire date required: `"HireDateMandatory"` or equivalent — need to identify exact key

**Resolution approach:** Since DTOs are kept as-is, and `ActivityFormModel.Validate()` uses hardcoded strings, the correct approach per CONTEXT.md is to inject ILocalizationService into the Validate() method via ValidationContext. The form model stores a reference set from the page component.

**Exact localization keys for validation errors** need to be located from the legacy ASPX source. Key candidates from context:

| Validation | Legacy Key Candidates |
|---|---|
| Deadline required | `"ApplicationDeadlineMandatory"` |
| Hire date required | `"HireDateMandatory"` |
| Hire date ordering | Need legacy audit |
| Hire date free text | Need legacy audit |

**Pragmatic option:** Since DTOs are kept as-is and validation keys need runtime resolution, the simplest approach is to set error messages on the form model before validation is triggered — not inside `Validate()`. This can be done by adding `string?` localized error message fields to the model that are set by the page before `EditForm.OnValidSubmit`. However, since DTOs are locked, the cleanest approach is to use `ValidationContext.GetService<ILocalizationService>()` inside `Validate()`.

**Source:** .NET DataAnnotationsValidator passes `IServiceProvider` (the component's DI container) into ValidationContext automatically when using Blazor's `DataAnnotationsValidator`. This means `context.GetService<ILocalizationService>()` will work. **Confidence: HIGH** (verified via .NET Blazor architecture knowledge, confirmed by the ValidationContext design).

### Finding 5: NavigationConfigService Already Updated (HIGH confidence)

**Verified by reading:** `NavigationConfigService.cs` line 131

The `ExtractActivityId` method already uses `segments.Length >= 3` (not `== 3`). This was already done per the research spec. **No change needed.**

### Finding 6: ClientSectionGroupId Not on Eractivity Entity (MEDIUM confidence)

**Verified by reading:** `Eractivity.cs` — no `ClientSectionGroupId` property found.

The service resolves ClientSectionGroupId from `a.ClientSection.ClientSectionGroupId` (via navigation property). The form model and save command have `ClientSectionGroupId` but `MapCommandToEntity` currently does NOT save it to the entity (there's no entity property to save to). The save command has the field but `MapCommandToEntity` ignores it — this is correct behavior since the entity has no such column. **ClientSectionGroupId is UI-only state** used to filter the section autocomplete. On save, only `ClientSectionId` is persisted.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| User search dialog | Custom modal | `UserPickerDialog` (already exists) | Complete implementation in Shared/Recruiting/ |
| Confirm dialog | Custom modal | `DialogService.ShowMessageBox(...)` | MudBlazor built-in pattern, already used |
| Client autocomplete | Custom search | `MudAutocomplete` + `SearchClientsAsync` | Pattern established in current impl |
| Section live-search | Custom search | `MudAutocomplete` + `GetClientSectionsForFormAsync` | Service method exists |
| Cascade loading | Custom spinner | `_cascadeLoading` bool + `Disabled` on inputs | Simple Blazor pattern, no library needed |
| Validation service | Custom validator | `IValidatableObject` + `DataAnnotationsValidator` | Already on ActivityFormModel |

---

## Common Pitfalls

### Pitfall 1: RecruitmentTypeId / LeadershipPosition / BlindRecruitment Divergence
**What goes wrong:** UI shows three separate dropdowns (RecruitmentType + LeadershipPosition + BlindRecruitment) because the current wrong implementation shows all three. The correct UI has EITHER: (a) a single `RecruitmentType` dropdown (when both LeadershipPosition and BlindRecruitment features are enabled on the client), or (b) separate `LeadershipPosition` and `BlindRecruitment` selects (when features are enabled individually).
**Why it happens:** The current implementation added all three, not understanding the legacy conditional logic.
**How to avoid:** Follow the legacy `PopulateLeadershipPositionsAndBlindRecruitment` logic: show `recruitmentType` when both features are enabled on the client; show individual selects otherwise.
**Resolution for this phase:** Per CONTEXT.md locked decision, show `RecruitmentTypeId` as the primary field. The ERRecruitmentType table provides the dropdown options. The `BuildSaveCommand()` translates the selected ID to `LeadershipPositionId` + `BlindRecruitmentId` on the command.

### Pitfall 2: CalendarType vs ClosedCalendar/OpenCalendar Checkbox UX
**What goes wrong:** CalendarTypeId = 0/1/2 stored in DB, but UI presents two checkboxes. If both are checked simultaneously, the DB state is ambiguous.
**Why it happens:** The spec chose checkboxes for UX reasons but the underlying storage is a single enum.
**How to avoid:** When both checkboxes are checked, show the CalendarType dropdown to resolve ambiguity. When deriving checkbox state from CalendarTypeId on load: `ClosedCalendarEnabled = (CalendarTypeId == 2)`, `OpenCalendarEnabled = (CalendarTypeId == 1)`. On save: if both checked → derive from CalendarType dropdown; if only one → that one wins.
**Per CONTEXT.md:** These fields are non-persisting (UI-only state). This is an accepted gap. The save should at minimum persist CalendarTypeId correctly.

### Pitfall 3: Template Group Cascade Scope
**What goes wrong:** Developer reloads ALL email/SMS templates on template group change, wiping user selections incorrectly.
**Why it happens:** Over-broad cascade trigger.
**How to avoid (locked decision):** Template group change ONLY reloads `ApplicationTemplates`. Email and SMS template lists are NOT filtered by template group and are NOT reloaded. Clear only `ApplicationTemplateId` selection.

### Pitfall 4: MudSelect Label-Gap Mismatch
**What goes wrong:** MudSelect inputs have 8px gap from external label; MudAutocomplete/MudTextField have 4px — form looks misaligned.
**Root cause:** MudSelect wrapper uses `display:flex` (blocks margin collapsing); others use `display:block`.
**How to avoid:** Always inject the HeadContent style fix.
**Source:** Project MEMORY.md — confirmed fix.

### Pitfall 5: SavedSuccessfully vs Navigate in Edit Mode
**What goes wrong:** Keeping `Snackbar.Add(...); // no navigate` after edit save causes user to stay on edit page.
**Locked decision:** After edit save → `Navigation.NavigateTo("/recruiting/activities")` — no snackbar, no stay-on-page.

### Pitfall 6: Occupation Autocomplete Not Reloading on Client Change
**What goes wrong:** Occupation list is global (not client-specific) but the occupation autocomplete's `_selectedOccupation` state is not cleared on client change.
**How to avoid:** On client change, clear `_selectedOccupation = null` and `_form.JobnetOccupationId = null`.

### Pitfall 7: ContinuousPosting + ApplicationDeadline = DateTime.MaxValue
**What goes wrong:** If ContinuousPosting=true and deadline is `DateTime.MaxValue`, editing the activity later shows `DateTime.MaxValue` in the date picker.
**How to avoid:** In `MapEditDataToForm`, apply `ApplicationDeadline = activity.ContinuousPosting ? null : activity.ApplicationDeadline` (the service already does this in `ActivityEditDto` creation at line 1413 of ErActivityService.cs).

### Pitfall 8: MudAutocomplete Ref Reset on Section Group Change
**What goes wrong:** When ClientSectionGroupId changes, the section autocomplete shows stale text from old selection.
**How to avoid:** Call `await _clientSectionAutocomplete.ResetAsync()` when section group changes (already done in current code).

---

## Code Examples

### MudGrid Responsive Layout (two-column form + sidebar)
```razor
<MudGrid>
    @* Left column *@
    <MudItem xs="12" md="8">
        <MudPaper Class="pa-4 mb-4" Elevation="1">
            <MudText Typo="Typo.h6" Class="mb-4">@Localization.GetText("MasterData")</MudText>
            <MudGrid>
                @* Fields: xs="12" sm="6" for side-by-side on desktop, full-width on mobile *@
                <MudItem xs="12" sm="6">
                    <div class="form-field">
                        <label class="field-label-text">@Localization.GetText("Status") <span class="required-mark">*</span></label>
                        <MudSelect T="int?" @bind-Value="_form.StatusId" Variant="Variant.Outlined" Margin="Margin.Dense">
                            ...
                        </MudSelect>
                        <ValidationMessage For="@(() => _form.StatusId)" />
                    </div>
                </MudItem>
            </MudGrid>
        </MudPaper>
    </MudItem>

    @* Right column (sidebar) *@
    <MudItem xs="12" md="4">
        ...
    </MudItem>
</MudGrid>
```

### BuildSaveCommand() with RecruitmentTypeId → LeadershipPositionId/BlindRecruitmentId Translation
```csharp
private ActivitySaveCommand BuildSaveCommand()
{
    // Translate RecruitmentTypeId to LeadershipPositionId/BlindRecruitmentId
    // ERRecruitmentType: 1=Normal, 2=LeadershipPosition, 3=BlindRecruitment
    // LeadershipPositionId/BlindRecruitmentId: 1=Yes, 2=No
    int? leadershipPositionId = _form.RecruitmentTypeId switch
    {
        2 => 1, // LeadershipPosition = Yes
        1 or 3 => 2, // Normal or BlindRecruitment = No
        _ => null
    };
    int? blindRecruitmentId = _form.RecruitmentTypeId switch
    {
        3 => 1, // BlindRecruitment = Yes
        1 or 2 => 2, // Normal or LeadershipPosition = No
        _ => null
    };

    // Derive CalendarTypeId from ClosedCalendar/OpenCalendar checkbox state
    // Note: ClosedCalendar/OpenCalendar are UI-only, non-persisting per CONTEXT.md
    int? calendarTypeId = _form.CalendarTypeId; // Use form's CalendarTypeId (from dropdown when both checked)
    if (_form.ClosedCalendarEnabled && !_form.OpenCalendarEnabled) calendarTypeId = 2;
    else if (_form.OpenCalendarEnabled && !_form.ClosedCalendarEnabled) calendarTypeId = 1;

    return new ActivitySaveCommand
    {
        LeadershipPositionId = leadershipPositionId,
        BlindRecruitmentId = blindRecruitmentId,
        CalendarTypeId = calendarTypeId,
        // ... rest of fields
    };
}
```

### MapEditDataToForm() with RecruitmentTypeId ← LeadershipPositionId/BlindRecruitmentId Translation
```csharp
// Translate LeadershipPositionId/BlindRecruitmentId → single RecruitmentTypeId
// LeadershipPositionId = 1 means IsLeadershipPosition=true → RecruitmentTypeId=2
// BlindRecruitmentId = 1 means IsBlindRecruitment=true → RecruitmentTypeId=3
// Otherwise → RecruitmentTypeId=1 (Normal)
_form.RecruitmentTypeId = data.LeadershipPositionId == 1 ? 2 :
                          data.BlindRecruitmentId == 1 ? 3 :
                          (data.LeadershipPositionId.HasValue || data.BlindRecruitmentId.HasValue) ? 1 : null;

// Derive ClosedCalendarEnabled/OpenCalendarEnabled from CalendarTypeId
_form.ClosedCalendarEnabled = data.CalendarTypeId == 2;
_form.OpenCalendarEnabled = data.CalendarTypeId == 1;
```

### Cascade Loading State Pattern
```csharp
private bool _cascadeLoading;

private async Task OnClientChangedAsync(ClientDropdownDto? client)
{
    _selectedClient = client;
    _form.ClientId = client?.ClientId;

    // Clear client-dependent selections
    _form.ClientSectionGroupId = null;
    _form.ClientSectionId = null;
    _selectedClientSection = null;
    _selectedOccupation = null;
    _form.JobnetOccupationId = null;
    _form.TemplateGroupId = null;
    _form.ApplicationTemplateId = null;
    // ... clear all template IDs

    if (client != null)
    {
        _cascadeLoading = true;
        StateHasChanged();
        try
        {
            await LoadClientDependentDataAsync(client.ClientId);
        }
        finally
        {
            _cascadeLoading = false;
        }
    }
    else
    {
        _clientConfig = new ActivityClientConfigDto();
        _options = new ActivityFormOptionsDto();
    }
}
```

### IValidatableObject with Localization via ValidationContext
```csharp
// ActivityFormModel.Validate() — uses localization service from ValidationContext
public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
{
    var loc = validationContext.GetService<ILocalizationService>();

    if (!ContinuousPosting && !ApplicationDeadline.HasValue)
        yield return new ValidationResult(
            loc?.GetText("ApplicationDeadlineMandatory") ?? "Application deadline is required.",
            new[] { nameof(ApplicationDeadline) });

    if (HireDateType == 1 && !HireDate.HasValue)
        yield return new ValidationResult(
            loc?.GetText("HireDateMandatory") ?? "Hire date is required.",
            new[] { nameof(HireDate) });

    if (HireDateType == 1 && HireDate.HasValue && ApplicationDeadline.HasValue
        && HireDate.Value < ApplicationDeadline.Value)
        yield return new ValidationResult(
            loc?.GetText("HireDateMustBeAfterDeadline") ?? "Hire date must be on or after the application deadline.",
            new[] { nameof(HireDate) });

    if (HireDateType == 2 && string.IsNullOrWhiteSpace(HireDateFreeText))
        yield return new ValidationResult(
            loc?.GetText("HireDateFreeTextMandatory") ?? "Hire date text is required.",
            new[] { nameof(HireDateFreeText) });
}
```

**Note:** The exact localization key names for validation messages need to be confirmed against the legacy DB. The above are educated guesses from naming convention patterns. Fallback to hardcoded English (already present) prevents silent failures during migration.

### Post-Edit-Save Navigation (Correct)
```csharp
private async Task OnSaveAsync()
{
    _saveError = null;
    _saving = true;
    StateHasChanged();

    try
    {
        var command = BuildSaveCommand();

        if (IsEditMode && ActivityId.HasValue)
        {
            await ErActivityService.UpdateActivityAsync(ActivityId.Value, command);
            Navigation.NavigateTo("/recruiting/activities"); // Navigate away, no snackbar
        }
        else
        {
            var newId = await ErActivityService.CreateActivityAsync(command);
            Navigation.NavigateTo($"/recruiting/activities/{newId}/edit");
        }
    }
    catch (Exception ex)
    {
        _saveError = $"{Localization.GetText("SaveFailed")}: {ex.Message}";
        _saving = false; // Only reset if NOT navigating
    }
    // No finally _saving = false — navigation destroys the component
}
```

---

## What the Rewrite Must Fix (Defect List)

| # | Defect | Where | Fix |
|---|--------|-------|-----|
| 1 | Edit save does not navigate away | .razor.cs OnSaveAsync | Replace Snackbar+stay with NavigateTo("/recruiting/activities") |
| 2 | RecruitmentType dropdown should show ERRecruitmentType rows, not duplicate Leadership/BlindRecruitment | .razor | Single MudSelect for RecruitmentTypeId only; remove separate Leadership/BlindRecruitment selects from the main form (they are only shown when client uses separate feature flags) |
| 3 | Validation messages are hardcoded English | ActivityFormModel.cs | Inject ILocalizationService via ValidationContext — but ActivityFormModel is locked (no DTO changes). The fix is in the Validate() method using GetService pattern |
| 4 | CalendarTypeId not derived from checkbox state on save | .razor.cs BuildSaveCommand | Derive CalendarTypeId from ClosedCalendarEnabled/OpenCalendarEnabled booleans |
| 5 | CalendarTypeId not mapped to checkbox state on edit load | .razor.cs MapEditDataToForm | Derive _form.ClosedCalendarEnabled/_form.OpenCalendarEnabled from CalendarTypeId |
| 6 | RecruitmentTypeId not translated from LeadershipPositionId/BlindRecruitmentId on edit load | .razor.cs MapEditDataToForm | Translate as shown in code examples above |
| 7 | RecruitmentTypeId not translated to LeadershipPositionId/BlindRecruitmentId on save | .razor.cs BuildSaveCommand | Translate as shown in code examples above |
| 8 | No cascade loading state visible during client change | .razor.cs + .razor | Add `_cascadeLoading` bool, disable affected fields while reloading |
| 9 | Template group cascade reloads nothing visible | .razor.cs | Already correct: only reloads ApplicationTemplates; confirm no extra reload |
| 10 | `LockCandidateEvaluation` localization key wrong in current razor | .razor | Current uses "LockCandidateEvaluation" but legacy uses "HideCandidateEvalutionAndNotesWhenUserHasNotEvaluated" |

---

## Localization Keys Reference

All keys from `.planning/research/ActivityCreateEditMigration.md` (authoritative):

**Master data labels:**
`"MasterData"`, `"CreatedBy"`, `"ActivityId"`, `"CreateDate"` (for read-only header), `"Client"`, `"Status"`, `"Headline"`, `"Jobtitle"` (note: legacy uses "Jobtitle" not "JobTitle"), `"ERActivityJobnetOccupation"`, `"ClientSection"`, `"ClientSectionGroup"`, `"Reposting"`, `"LeadershipPosition"`, `"BlindRecruitment"`, `"RecruitmentType"`, `"HideCandidateEvalutionAndNotesWhenUserHasNotEvaluated"`, `"ViewRecruitmentCommitteeEvaluations"`, `"SendEmailOnNewCandidate"`, `"SendDailyStatusMail"`, `"ContinuousPosting"`, `"ApplicationDeadline"`, `"HireDate"`, `"NoHireDate"` (legacy: check actual key), `"Date"`, `"Freetext"`, `"InterviewRounds"`, `"CalendarType"`, `"ClosedCalendarEnabled"`, `"OpenCalendarEnabled"`, `"InterviewDuration"`, `"InterviewSchedule"`, `"SendSmsInterviewRemembrances"`, `"ExtendedEvaluationEnabled"`, `"ExtendedEvaluationCriterias"`, `"Language"`

**Template labels:**
`"Templates"`, `"WorkArea"`, `"TemplateGroup"`, `"ApplicationTemplate"`, `"ReceivedEmail"`, `"InterviewEmailForSelected"`, `"InterviewEmailFirstRoundForSelected"`, `"InterviewEmailTwoPlusRoundsForSelected"`, `"RejectedEmailForNotSelected"`, `"RejectedEmailAfterInterview"`, `"NotifyRecruitmentCommitteeEmail"`, `"InterviewSmsForSelected"`

**Sidebar:**
`"RecruitingResponsable"` (for non-fund), `"RecruitingResponsableFund"` (for fund clients), `"RecruitingResponsableAlternative"` (alternative responsible header), `"RecruitmentCommittee"`, `"ManageCommittee"`

**Buttons:**
`"Save"`, `"Cancel"`, `"Delete"`, `"CloseActivity"`, `"Change"`, `"Add"`, `"Select"`, `"Search"`, `"NoResults"`, `"Name"`, `"Type"`

**Confirm dialogs:**
`"ConfirmDelete"`, `"ConfirmCloseActivity"` (exact keys need legacy audit — fallback to localization key pattern)

**Validation errors (exact keys need legacy audit — use these as best-guess fallbacks):**
`"ApplicationDeadlineMandatory"`, `"HireDateMandatory"`, `"HireDateMustBeAfterDeadline"`, `"HireDateFreeTextMandatory"`

---

## Open Questions

1. **Exact localization keys for validation error messages**
   - What we know: current code uses hardcoded English
   - What's unclear: exact keys in the `Localization` table for deadline-required, hire-date-required, hire-date-ordering, hire-date-freetext-required
   - Recommendation: Search legacy ASPX for GetText calls near validation logic; if not found, use English fallback (safe — key resolves to [key] if missing, which is acceptable for now)

2. **"NoHireDate" localization key**
   - What we know: current razor uses "NoHireDate" for the radio option
   - What's unclear: whether legacy uses this exact key or a different one
   - Recommendation: Keep "NoHireDate" as it follows the pattern; if it resolves to "[NoHireDate]" in testing, look up the correct key

3. **RecruitmentTypeId dropdown conditional visibility (leadershipPositionEnabled AND blindRecruitmentEnabled both required to show combined dropdown)**
   - What we know: legacy shows a combined recruitmentType dropdown ONLY when both features enabled on client; otherwise shows individual selects
   - What's unclear: the ActivityClientConfigDto does not have separate `LeadershipPositionEnabled` and `BlindRecruitmentEnabled` flags — only `UseTemplateGroups`, etc.
   - Recommendation: Per CONTEXT.md, "RecruitmentTypeId — This is a REQUIRED field." Show the RecruitmentType dropdown unconditionally (using the ERRecruitmentType lookup). This matches the locked decision that RecruitmentTypeId is always required.

4. **CreateDate localization key in read-only info card**
   - What we know: current code uses "CreateDate"
   - What's unclear: current ActivityEditDto has `CreateDate` property; legacy key might be "Created" or "CreateDate"
   - Recommendation: Use "CreateDate" (already in current code); verify in legacy if this resolves correctly

---

## Validation Architecture

Not applicable — `workflow.nyquist_validation` is not set to `true` in `.planning/config.json` (key absent). Skipping this section.

---

## Sources

### Primary (HIGH confidence)
- Direct codebase audit: `src/SignaturPortal.Infrastructure/Data/Entities/Eractivity.cs` — confirmed entity columns
- Direct codebase audit: `src/SignaturPortal.Infrastructure/Services/ErActivityService.cs` — confirmed service implementation
- Direct codebase audit: `src/SignaturPortal.Infrastructure/Services/ClientService.cs` — confirmed config implementation
- Direct codebase audit: `src/SignaturPortal.Web/Components/Pages/Recruiting/ActivityCreateEdit.razor` and `.razor.cs` — current wrong implementation
- Direct codebase audit: `src/SignaturPortal.Application/DTOs/ActivityFormModel.cs` + other DTOs — confirmed DTO structure
- Direct legacy audit: `C:/Dev/Dev3Org/AtlantaSignatur/Web/MainSite/Responsive/Recruiting/ActivityCreateEdit.aspx.cs` — confirmed RecruitmentTypeEn enum, CalendarType, IsLeadershipPosition/IsBlindRecruitment save logic
- `.planning/research/ActivityCreateEditMigration.md` — authoritative spec for field order, cascade logic, localization keys
- `.planning/phases/03.9-redo-activitycreateedit-ui-migration-with-full-fidelity/03.9-CONTEXT.md` — locked decisions

### Secondary (MEDIUM confidence)
- Project MEMORY.md — MudSelect label-gap fix (`.activity-form .mud-input-control { margin-top: 0 !important; }`)
- .NET Blazor DataAnnotationsValidator behavior — ValidationContext populates IServiceProvider from component DI container

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — all libraries already installed and in use
- Architecture: HIGH — patterns verified from existing code
- Pitfalls: HIGH — confirmed from legacy ASPX source audit and current implementation defects
- Data model: HIGH — confirmed by reading actual EF entity scaffold

**Research date:** 2026-02-23
**Valid until:** Stable — no external dependencies, all findings from in-repo code

---

## Planning Guidance

This phase is a single-component rewrite. Suggested plan breakdown:

**Plan 03.9-01:** Rewrite ActivityCreateEdit.razor.cs (code-behind only)
- Fix MapEditDataToForm: RecruitmentTypeId translation, CalendarType→checkbox derivation
- Fix BuildSaveCommand: RecruitmentTypeId→Leadership/BlindRecruitment translation, CalendarTypeId derivation
- Fix OnSaveAsync: navigate to `/recruiting/activities` after edit save (remove Snackbar)
- Add `_cascadeLoading` bool + loading state to OnClientChangedAsync
- Ensure `ActivityFormModel.Validate()` uses ValidationContext.GetService for localization

**Plan 03.9-02:** Rewrite ActivityCreateEdit.razor (markup only)
- Use MudPaper containers (or MudCard per Claude's discretion)
- Follow field order from ActivityCreateEditMigration.md exactly
- Show single RecruitmentType dropdown (not duplicate Leadership+BlindRecruitment)
- Apply cascade loading Disabled states to all client-dependent fields
- Verify all 80+ localization keys match legacy spec

**Plan 03.9-03:** Rewrite ActivityCreateEdit.razor.css + verify checklist
- CSS follows ActivityList.razor.css breakpoint pattern
- Run through all 17 verification checklist items from ActivityCreateEditMigration.md
