---
phase: 05-localization-ux-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SignaturPortal.Domain/Enums/AppLanguage.cs
  - src/SignaturPortal.Infrastructure/Data/Entities/LocalizationEntry.cs
  - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
  - src/SignaturPortal.Infrastructure/Localization/DbStringLocalizer.cs
  - src/SignaturPortal.Infrastructure/Localization/DbStringLocalizerFactory.cs
  - src/SignaturPortal.Infrastructure/Localization/LocalizationCacheService.cs
  - src/SignaturPortal.Infrastructure/DependencyInjection.cs
  - src/SignaturPortal.Web/Middleware/LanguageCultureMiddleware.cs
  - src/SignaturPortal.Web/Program.cs
  - src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj
  - src/SignaturPortal.Web/SignaturPortal.Web.csproj
autonomous: true

must_haves:
  truths:
    - "IStringLocalizer resolves localization keys from the Localization DB table"
    - "Fallback from requested language to English works when a key has no translation"
    - "All ~13,700 enabled localization rows are cached in memory at startup"
    - "CultureInfo is set based on UserLanguageId from the scoped session context"
    - "Format string placeholders ({0}, {1}) are applied via string.Format"
  artifacts:
    - path: "src/SignaturPortal.Domain/Enums/AppLanguage.cs"
      provides: "Language enum matching legacy (EN=1, DK=3)"
      contains: "enum AppLanguage"
    - path: "src/SignaturPortal.Infrastructure/Data/Entities/LocalizationEntry.cs"
      provides: "EF Core entity for Localization table"
      contains: "class LocalizationEntry"
    - path: "src/SignaturPortal.Infrastructure/Localization/DbStringLocalizer.cs"
      provides: "Custom IStringLocalizer reading from DB/cache"
      contains: "class DbStringLocalizer"
    - path: "src/SignaturPortal.Infrastructure/Localization/DbStringLocalizerFactory.cs"
      provides: "Factory creating DbStringLocalizer instances"
      contains: "class DbStringLocalizerFactory"
    - path: "src/SignaturPortal.Infrastructure/Localization/LocalizationCacheService.cs"
      provides: "IHostedService that warms the localization cache at startup"
      contains: "class LocalizationCacheService"
    - path: "src/SignaturPortal.Web/Middleware/LanguageCultureMiddleware.cs"
      provides: "Middleware setting CultureInfo from UserLanguageId"
      contains: "class LanguageCultureMiddleware"
  key_links:
    - from: "src/SignaturPortal.Infrastructure/Localization/DbStringLocalizer.cs"
      to: "IMemoryCache"
      via: "cache lookup with fallback to DB"
      pattern: "_cache\\.TryGetValue"
    - from: "src/SignaturPortal.Infrastructure/Localization/LocalizationCacheService.cs"
      to: "SignaturDbContext"
      via: "IDbContextFactory to load all enabled rows"
      pattern: "dbFactory\\.CreateDbContext"
    - from: "src/SignaturPortal.Web/Middleware/LanguageCultureMiddleware.cs"
      to: "IUserSessionContext"
      via: "reads UserLanguageId to set CultureInfo"
      pattern: "session\\.UserLanguageId"
---

<objective>
Build the database-backed localization infrastructure: EF Core entity for the Localization table, custom IStringLocalizer/IStringLocalizerFactory backed by IMemoryCache, a startup cache warmer, and culture middleware that maps UserLanguageId to CultureInfo.

Purpose: This is the foundation for all UI text localization. The legacy app reads ~13,700 localization strings from the Localization table with in-memory caching and language fallback (DK -> EN). This plan replicates that exact behavior using ASP.NET Core's IStringLocalizer abstraction.

Output: A fully wired localization pipeline -- inject IStringLocalizer into any component and get the correct language string from the database cache.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-localization-ux-polish/05-RESEARCH.md
@src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
@src/SignaturPortal.Infrastructure/DependencyInjection.cs
@src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
@src/SignaturPortal.Web/Services/UserSessionContext.cs
@src/SignaturPortal.Web/Program.cs
@src/SignaturPortal.Web/Middleware/UserSessionMiddleware.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Localization entity, DbStringLocalizer, factory, and cache warmer</name>
  <files>
    src/SignaturPortal.Domain/Enums/AppLanguage.cs
    src/SignaturPortal.Infrastructure/Data/Entities/LocalizationEntry.cs
    src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
    src/SignaturPortal.Infrastructure/Localization/DbStringLocalizer.cs
    src/SignaturPortal.Infrastructure/Localization/DbStringLocalizerFactory.cs
    src/SignaturPortal.Infrastructure/Localization/LocalizationCacheService.cs
    src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj
  </files>
  <action>
    1. Create `src/SignaturPortal.Domain/Enums/AppLanguage.cs` with enum matching legacy `GenericObjects.Language`:
       - Default=0, EN=1, DK=3, DE=4, ES=5 (FR=2 intentionally omitted -- no data in DB)

    2. Create `src/SignaturPortal.Infrastructure/Data/Entities/LocalizationEntry.cs`:
       - Properties: Id (int PK), Area (string, varchar 50), Key (string, varchar 128), Value (string, nvarchar max), SiteId (int), Enabled (bool), LanguageId (int), LocalizationTypeId (int), CreateDate (DateTime), ModifiedDate (DateTime), Approved (bool)
       - This maps to the existing `Localization` table in the database

    3. Add to `SignaturDbContext`:
       - `public virtual DbSet<LocalizationEntry> Localizations { get; set; }`
       - In `OnModelCreating`, configure: `entity.ToTable("Localization"); entity.HasKey(e => e.Id); entity.Property(e => e.Key).HasMaxLength(128).IsUnicode(false); entity.Property(e => e.Area).HasMaxLength(50).IsUnicode(false); entity.Property(e => e.Value).IsRequired();`

    4. Add package reference to `SignaturPortal.Infrastructure.csproj`:
       - `Microsoft.Extensions.Localization` (needed for IStringLocalizer/IStringLocalizerFactory interfaces)

    5. Create `src/SignaturPortal.Infrastructure/Localization/DbStringLocalizer.cs`:
       - Implements `IStringLocalizer`
       - Constructor takes `IMemoryCache cache, IDbContextFactory<SignaturDbContext> dbFactory, int languageId`
       - CRITICAL: Accept `int languageId` directly (NOT CultureInfo string). This avoids Pitfall 5 from research -- SignalR circuits don't propagate CultureInfo, but the scoped UserSessionContext survives. The factory will read UserLanguageId from session context.
       - `this[string name]`: Look up key via `GetString(name)`, return `new LocalizedString(name, value ?? name, value == null)`
       - `this[string name, params object[] arguments]`: Same but apply `string.Format(value, arguments)` when value is not null (matches legacy GetText behavior)
       - `GetString(string key)`: Cache key = `$"Loc_{key}_{languageId}"`. Try cache first. On miss, query DB: `WHERE Key == key AND LanguageId == languageId AND Enabled`. If no result and languageId != 1, fallback query with LanguageId=1 (EN). Cache the result (or sentinel "N/A" for null) with 1-hour sliding expiration. Return value or null.
       - `GetAllStrings`: Return `Enumerable.Empty<LocalizedString>()` (not needed)

    6. Create `src/SignaturPortal.Infrastructure/Localization/DbStringLocalizerFactory.cs`:
       - Implements `IStringLocalizerFactory`
       - Constructor takes `IMemoryCache cache, IDbContextFactory<SignaturDbContext> dbFactory, IHttpContextAccessor httpContextAccessor`
       - Both `Create(Type)` and `Create(string, string)` methods resolve the language from the scoped `IUserSessionContext`:
         - Get `IUserSessionContext` from `httpContextAccessor.HttpContext.RequestServices`
         - If initialized, use `session.UserLanguageId`; otherwise default to 1 (EN)
       - Return `new DbStringLocalizer(cache, dbFactory, languageId)`

    7. Create `src/SignaturPortal.Infrastructure/Localization/LocalizationCacheService.cs`:
       - Implements `IHostedService`
       - `StartAsync`: Create scope, get `IDbContextFactory<SignaturDbContext>`, create context, load ALL enabled rows (`WHERE Enabled == true`), cache each as `$"Loc_{entry.Key}_{entry.LanguageId}"` with 24-hour absolute expiration
       - `StopAsync`: No-op
       - Log the count of loaded entries for diagnostics
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj` -- must compile with no errors.
  </verify>
  <done>
    LocalizationEntry entity maps to the Localization table. DbStringLocalizer reads from IMemoryCache with DB fallback and language fallback (DK->EN). DbStringLocalizerFactory resolves language from UserSessionContext. LocalizationCacheService warms cache at startup with all enabled entries.
  </done>
</task>

<task type="auto">
  <name>Task 2: DI registration, culture middleware, and Program.cs wiring</name>
  <files>
    src/SignaturPortal.Infrastructure/DependencyInjection.cs
    src/SignaturPortal.Web/Middleware/LanguageCultureMiddleware.cs
    src/SignaturPortal.Web/Program.cs
    src/SignaturPortal.Web/SignaturPortal.Web.csproj
  </files>
  <action>
    1. Add package reference to `SignaturPortal.Web.csproj`:
       - `Microsoft.Extensions.Localization` (for AddLocalization extension method)

    2. Update `src/SignaturPortal.Infrastructure/DependencyInjection.cs` -- add to `AddInfrastructure`:
       - `services.AddMemoryCache();` (needed by DbStringLocalizer and LocalizationCacheService)
       - `services.AddSingleton<IStringLocalizerFactory, DbStringLocalizerFactory>();` (singleton -- cache and factory are thread-safe)
       - `services.AddHostedService<LocalizationCacheService>();` (warm cache on startup)
       - Add necessary using statements for the Localization namespace

    3. Create `src/SignaturPortal.Web/Middleware/LanguageCultureMiddleware.cs`:
       - Standard middleware pattern with RequestDelegate
       - `InvokeAsync(HttpContext context)`: Resolve `IUserSessionContext` from `context.RequestServices`
       - If session is initialized and UserLanguageId > 0, map to CultureInfo:
         - 3 -> "da-DK", 4 -> "de-DE", 5 -> "es-ES", _ -> "en-US"
       - Set both `CultureInfo.CurrentCulture` and `CultureInfo.CurrentUICulture`
       - Call `_next(context)`
       - NOTE: This middleware sets culture for the initial SSR HTTP request. For subsequent SignalR interactions, the DbStringLocalizer reads UserLanguageId directly from the scoped session context, so culture propagation is not an issue.

    4. Update `src/SignaturPortal.Web/Program.cs`:
       - Add `builder.Services.AddLocalization();` after `AddMudServices()`
       - Add `app.UseMiddleware<LanguageCultureMiddleware>();` AFTER `app.UseMiddleware<UserSessionMiddleware>()` (culture middleware needs session context to be populated first)
       - Add `app.UseRequestLocalization(...)` with `SetDefaultCulture("da-DK")`, `AddSupportedCultures("da-DK", "en-US")`, `AddSupportedUICultures("da-DK", "en-US")` -- place AFTER the culture middleware
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.Web/SignaturPortal.Web.csproj` -- must compile with no errors. Then run `dotnet build` from solution root to verify full solution compiles.
  </verify>
  <done>
    The full localization pipeline is wired: cache warms on startup, culture middleware sets CultureInfo from session, IStringLocalizer is injectable in any component and returns the correct language string from the Localization table cache. Solution compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` from solution root compiles with zero errors
- LocalizationEntry entity is configured in SignaturDbContext with correct table mapping
- DbStringLocalizer uses IMemoryCache with DB fallback and language fallback chain
- DbStringLocalizerFactory reads UserLanguageId from scoped IUserSessionContext (not CultureInfo)
- LocalizationCacheService loads all enabled rows at startup
- LanguageCultureMiddleware is placed after UserSessionMiddleware in pipeline
</verification>

<success_criteria>
- IStringLocalizer can be injected into a Blazor component and returns localized strings
- The Localization table is read via EF Core and cached in memory
- Language fallback (DK -> EN) works for missing translations
- Format string placeholders work via string.Format
- CultureInfo is set from UserLanguageId for SSR requests
</success_criteria>

<output>
After completion, create `.planning/phases/05-localization-ux-polish/05-01-SUMMARY.md`
</output>
