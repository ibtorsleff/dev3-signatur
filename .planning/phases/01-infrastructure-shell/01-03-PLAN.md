---
phase: 01-infrastructure-shell
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj
  - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
  - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
  - src/SignaturPortal.Infrastructure/Data/Entities/
  - src/SignaturPortal.Domain/Interfaces/IRepository.cs
  - src/SignaturPortal.Domain/Interfaces/IUnitOfWork.cs
  - src/SignaturPortal.Infrastructure/Repositories/Repository.cs
  - src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs
  - src/SignaturPortal.Application/DTOs/ClientDto.cs
  - src/SignaturPortal.Application/Mappings/ClientMappings.cs
  - src/SignaturPortal.Infrastructure/DependencyInjection.cs
  - src/SignaturPortal.Web/SignaturPortal.Web.csproj
  - src/SignaturPortal.Web/Program.cs
autonomous: true

must_haves:
  truths:
    - "EF Core DbContext is scaffolded from the existing database with entity classes generated"
    - "IDbContextFactory is registered for Blazor Server circuit-safe database access"
    - "Repository interfaces are defined in Domain layer with no EF Core dependency"
    - "Repository implementations in Infrastructure use IDbContextFactory to create per-operation contexts"
    - "Unit of Work pattern coordinates transaction scope across repositories"
    - "DTO extension methods (ToDto, ProjectToDto) map entities to DTOs without AutoMapper"
    - "A query through the repository returns data from the existing database mapped to a DTO"
  artifacts:
    - path: "src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs"
      provides: "EF Core DbContext scaffolded from existing database"
      contains: "partial class SignaturDbContext"
    - path: "src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs"
      provides: "Custom DbContext extensions (tenant properties, partial method)"
      contains: "CurrentSiteId"
    - path: "src/SignaturPortal.Domain/Interfaces/IRepository.cs"
      provides: "Generic repository interface in Domain layer"
      contains: "interface IRepository"
    - path: "src/SignaturPortal.Domain/Interfaces/IUnitOfWork.cs"
      provides: "Unit of Work interface in Domain layer"
      contains: "interface IUnitOfWork"
    - path: "src/SignaturPortal.Infrastructure/Repositories/Repository.cs"
      provides: "Generic repository implementation using EF Core"
      contains: "class Repository"
    - path: "src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs"
      provides: "Unit of Work implementation coordinating DbContext"
      contains: "class UnitOfWork"
    - path: "src/SignaturPortal.Application/DTOs/ClientDto.cs"
      provides: "Client DTO record for data transfer"
      contains: "record ClientDto"
    - path: "src/SignaturPortal.Application/Mappings/ClientMappings.cs"
      provides: "Manual mapping extensions ToDto and ProjectToDto"
      contains: "ProjectToDto"
    - path: "src/SignaturPortal.Infrastructure/DependencyInjection.cs"
      provides: "Infrastructure layer DI registration extension method"
      contains: "AddInfrastructure"
  key_links:
    - from: "src/SignaturPortal.Infrastructure/Repositories/Repository.cs"
      to: "src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs"
      via: "IDbContextFactory<SignaturDbContext>"
      pattern: "IDbContextFactory.*SignaturDbContext"
    - from: "src/SignaturPortal.Infrastructure/DependencyInjection.cs"
      to: "src/SignaturPortal.Web/Program.cs"
      via: "AddInfrastructure extension method"
      pattern: "AddInfrastructure"
    - from: "src/SignaturPortal.Application/Mappings/ClientMappings.cs"
      to: "src/SignaturPortal.Infrastructure/Data/Entities/"
      via: "Extension methods on entity types"
      pattern: "this Client client"
---

<objective>
Scaffold EF Core from the existing database, implement Repository and Unit of Work patterns with IDbContextFactory for circuit-safe access, create DTO mapping extensions, and wire up DI registration.

Purpose: This establishes the complete data access layer that all future phases depend on. EF Core provides type-safe database access, IDbContextFactory prevents Blazor Server circuit issues, repositories abstract EF Core from the domain layer, and DTOs provide clean data contracts.
Output: Working data access stack from database through EF Core through repository through DTO mapping, registered in DI.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-shell/01-RESEARCH.md
@.planning/phases/01-infrastructure-shell/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold EF Core DbContext and configure IDbContextFactory</name>
  <files>
    src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj
    src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs
    src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
    src/SignaturPortal.Infrastructure/Data/Entities/
    src/SignaturPortal.Web/SignaturPortal.Web.csproj
  </files>
  <action>
    Scaffold the EF Core DbContext from the existing SignaturAnnoncePortal database and set up IDbContextFactory:

    1. Add EF Core NuGet packages to Infrastructure project:
       ```
       dotnet add src/SignaturPortal.Infrastructure package Microsoft.EntityFrameworkCore --version 10.0.0
       dotnet add src/SignaturPortal.Infrastructure package Microsoft.EntityFrameworkCore.SqlServer --version 10.0.0
       ```
       If version 10.0.0 is unavailable, use the latest stable version matching the .NET SDK version.

    2. Install EF Core tools globally if not already installed:
       ```
       dotnet tool install --global dotnet-ef
       ```
       Or update: `dotnet tool update --global dotnet-ef`

    3. Scaffold the DbContext using SELECTIVE table scaffolding. The database has 455 tables -- do NOT scaffold all of them. Scaffold only the tables needed for Phase 1-3 (E-recruitment core):
       ```
       dotnet ef dbcontext scaffold "Server=.;Database=SignaturAnnoncePortal;Trusted_Connection=True;TrustServerCertificate=True;" Microsoft.EntityFrameworkCore.SqlServer --project src/SignaturPortal.Infrastructure --output-dir Data/Entities --context-dir Data --context SignaturDbContext --no-onconfiguring --force --table Client --table ERActivity --table ERCandidate --table ERActivityHiringTeam --table aspnet_Users --table aspnet_Membership --table aspnet_Roles --table aspnet_UsersInRoles --table Permission --table UserActivityLog --table Site
       ```

       IMPORTANT:
       - Use `--no-onconfiguring` to prevent hardcoded connection strings
       - Use `--force` to allow re-scaffolding later
       - If any table name is wrong (database may use different casing or names), check the database schema documentation at `C:\Users\it\Documents\Dev\CustomersAndProjects\Signatur\Dev3\SigDB.MD` and adjust table names accordingly
       - If the scaffold command fails because a table doesn't exist, remove that table from the command and note it in the summary. The key tables are Client, ERActivity, and Site.
       - The scaffolded files will be auto-generated. Do NOT manually edit them -- use partial classes instead.

    4. Create the custom partial class for DbContext extensions:
       File: `src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs`
       ```csharp
       using Microsoft.EntityFrameworkCore;

       namespace SignaturPortal.Infrastructure.Data;

       public partial class SignaturDbContext
       {
           /// <summary>
           /// Current site ID for multi-tenancy filtering.
           /// Set by TenantDbContextFactory or manually before queries.
           /// </summary>
           public string? CurrentSiteId { get; set; }

           /// <summary>
           /// Current client ID for multi-tenancy filtering.
           /// Set by TenantDbContextFactory or manually before queries.
           /// </summary>
           public int? CurrentClientId { get; set; }

           partial void OnModelCreatingPartial(ModelBuilder modelBuilder)
           {
               // Multi-tenancy query filters will be added in Phase 2 (SEC-02).
               // Placeholder for now to establish the partial class pattern.

               // Example of what Phase 2 will add:
               // modelBuilder.Entity<Client>()
               //     .HasQueryFilter(c => CurrentSiteId == null || c.SiteId == CurrentSiteId);
           }
       }
       ```

    5. Add EF Core SqlServer package to Web project for AddDbContextFactory registration:
       ```
       dotnet add src/SignaturPortal.Web package Microsoft.EntityFrameworkCore.SqlServer --version 10.0.0
       ```
       (Same version as Infrastructure. This is needed because the Web project calls AddDbContextFactory which needs the SQL Server provider.)

    NOTES:
    - Do NOT use EF Core migrations. The database schema is immutable (constraint from PROJECT.md).
    - Do NOT edit the scaffolded entity files. All customizations go in .Custom.cs partial classes.
    - The scaffold command must run from a directory where it can find the Infrastructure .csproj. Use `--project src/SignaturPortal.Infrastructure` from the solution root.
  </action>
  <verify>
    Run `dotnet build SignaturPortal.sln` -- must compile cleanly with EF Core packages and scaffolded entities.
    Verify scaffolded files exist:
    - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.cs exists and contains `partial class SignaturDbContext`
    - At least one entity file exists in src/SignaturPortal.Infrastructure/Data/Entities/ (e.g., Client.cs)
    - src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs exists with CurrentSiteId property
  </verify>
  <done>EF Core DbContext scaffolded from existing database with entity classes. Custom partial class created with tenant properties. No migrations created. Solution builds cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Repository, Unit of Work, DTO mappings, and DI registration</name>
  <files>
    src/SignaturPortal.Domain/Interfaces/IRepository.cs
    src/SignaturPortal.Domain/Interfaces/IUnitOfWork.cs
    src/SignaturPortal.Infrastructure/Repositories/Repository.cs
    src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs
    src/SignaturPortal.Application/DTOs/ClientDto.cs
    src/SignaturPortal.Application/Mappings/ClientMappings.cs
    src/SignaturPortal.Infrastructure/DependencyInjection.cs
    src/SignaturPortal.Web/Program.cs
  </files>
  <action>
    Create the Repository pattern, Unit of Work, DTO mappings, and wire everything together with DI:

    1. Create generic repository interface in Domain layer:
       File: `src/SignaturPortal.Domain/Interfaces/IRepository.cs`
       ```csharp
       namespace SignaturPortal.Domain.Interfaces;

       /// <summary>
       /// Generic repository interface. Domain layer has no EF Core dependency.
       /// </summary>
       public interface IRepository<T> where T : class
       {
           Task<T?> GetByIdAsync(object id, CancellationToken ct = default);
           Task<IReadOnlyList<T>> GetAllAsync(CancellationToken ct = default);
           Task<T> AddAsync(T entity, CancellationToken ct = default);
           void Update(T entity);
           void Remove(T entity);
       }
       ```

    2. Create Unit of Work interface in Domain layer:
       File: `src/SignaturPortal.Domain/Interfaces/IUnitOfWork.cs`
       ```csharp
       namespace SignaturPortal.Domain.Interfaces;

       /// <summary>
       /// Unit of Work interface for transaction coordination.
       /// Implementations in Infrastructure layer manage DbContext lifetime.
       /// </summary>
       public interface IUnitOfWork : IAsyncDisposable
       {
           /// <summary>
           /// Persists all pending changes to the database.
           /// </summary>
           Task<int> SaveChangesAsync(CancellationToken ct = default);
       }
       ```

    3. Create generic repository implementation in Infrastructure layer:
       File: `src/SignaturPortal.Infrastructure/Repositories/Repository.cs`
       ```csharp
       using Microsoft.EntityFrameworkCore;
       using SignaturPortal.Domain.Interfaces;
       using SignaturPortal.Infrastructure.Data;

       namespace SignaturPortal.Infrastructure.Repositories;

       /// <summary>
       /// Generic repository implementation using EF Core.
       /// Each instance creates its own DbContext via IDbContextFactory for Blazor Server circuit safety.
       /// </summary>
       public class Repository<T> : IRepository<T> where T : class
       {
           protected readonly SignaturDbContext Context;
           protected readonly DbSet<T> DbSet;

           public Repository(SignaturDbContext context)
           {
               Context = context;
               DbSet = context.Set<T>();
           }

           public virtual async Task<T?> GetByIdAsync(object id, CancellationToken ct = default)
           {
               return await DbSet.FindAsync(new[] { id }, ct);
           }

           public virtual async Task<IReadOnlyList<T>> GetAllAsync(CancellationToken ct = default)
           {
               return await DbSet.AsNoTracking().ToListAsync(ct);
           }

           public virtual async Task<T> AddAsync(T entity, CancellationToken ct = default)
           {
               var entry = await DbSet.AddAsync(entity, ct);
               return entry.Entity;
           }

           public virtual void Update(T entity)
           {
               DbSet.Update(entity);
           }

           public virtual void Remove(T entity)
           {
               DbSet.Remove(entity);
           }
       }
       ```

    4. Create Unit of Work implementation:
       File: `src/SignaturPortal.Infrastructure/Repositories/UnitOfWork.cs`
       ```csharp
       using Microsoft.EntityFrameworkCore;
       using SignaturPortal.Domain.Interfaces;
       using SignaturPortal.Infrastructure.Data;

       namespace SignaturPortal.Infrastructure.Repositories;

       /// <summary>
       /// Unit of Work implementation that owns a DbContext instance.
       /// Created via IDbContextFactory for Blazor Server circuit safety.
       /// Dispose the UnitOfWork to dispose the underlying DbContext.
       /// </summary>
       public class UnitOfWork : IUnitOfWork
       {
           private readonly SignaturDbContext _context;

           public UnitOfWork(IDbContextFactory<SignaturDbContext> contextFactory)
           {
               _context = contextFactory.CreateDbContext();
           }

           /// <summary>
           /// Gets a repository for the specified entity type.
           /// Repository shares this UnitOfWork's DbContext for transaction coordination.
           /// </summary>
           public IRepository<T> Repository<T>() where T : class
           {
               return new Repository<T>(_context);
           }

           public async Task<int> SaveChangesAsync(CancellationToken ct = default)
           {
               return await _context.SaveChangesAsync(ct);
           }

           public async ValueTask DisposeAsync()
           {
               await _context.DisposeAsync();
           }
       }
       ```

    5. Create Client DTO in Application layer:
       File: `src/SignaturPortal.Application/DTOs/ClientDto.cs`
       ```csharp
       namespace SignaturPortal.Application.DTOs;

       /// <summary>
       /// Client data transfer object for presentation layer consumption.
       /// </summary>
       public record ClientDto(
           int ClientId,
           string? SiteId,
           string? CompanyName,
           string? Email,
           bool IsActive);
       ```
       IMPORTANT: Adjust property names and types to match the actual scaffolded Client entity. Read the scaffolded Client.cs to determine exact property names (they may differ: ClientId vs Id, CompanyName vs Name, etc.).

    6. Create Client mapping extensions in Application layer:
       File: `src/SignaturPortal.Application/Mappings/ClientMappings.cs`
       ```csharp
       using SignaturPortal.Application.DTOs;

       namespace SignaturPortal.Application.Mappings;

       /// <summary>
       /// Manual mapping extensions for Client entity to DTO.
       /// No AutoMapper -- explicit mapping for clarity and performance.
       /// </summary>
       public static class ClientMappings
       {
           // IMPORTANT: The entity type must match the scaffolded entity.
           // Adjust the using directive and property accesses based on the actual
           // scaffolded entity name and namespace.

           // Example (adjust after reading scaffolded entity):
           // public static ClientDto ToDto(this Infrastructure.Data.Entities.Client client)
           // {
           //     return new ClientDto(
           //         client.ClientId,
           //         client.SiteId,
           //         client.CompanyName,
           //         client.Email,
           //         client.StatusId == 1);
           // }
           //
           // public static IQueryable<ClientDto> ProjectToDto(this IQueryable<Infrastructure.Data.Entities.Client> query)
           // {
           //     return query.Select(c => new ClientDto(
           //         c.ClientId,
           //         c.SiteId,
           //         c.CompanyName,
           //         c.Email,
           //         c.StatusId == 1));
           // }
       }
       ```
       CRITICAL: The executor must read the actual scaffolded Client entity to implement the correct mapping. The entity will be in `src/SignaturPortal.Infrastructure/Data/Entities/Client.cs` after Task 1. Map whatever properties exist. At minimum, map the primary key and any name/identifier fields.

       For this to compile, Application needs to reference the entity types. Since entities live in Infrastructure and Application should not reference Infrastructure directly, there are two approaches:
       - Option A (pragmatic): Add a reference from Application to Infrastructure (breaks strict Clean Architecture but is common in practice)
       - Option B (purist): Define mapping interfaces in Application, implement in Infrastructure

       Use Option B: Create the mapping extension methods in the Infrastructure layer instead, in a file like `src/SignaturPortal.Infrastructure/Mappings/ClientMappings.cs`, since Infrastructure already references Application (can access DTOs) and owns the entities. The Application layer just defines the DTO.

    7. Create Infrastructure DI registration extension method:
       File: `src/SignaturPortal.Infrastructure/DependencyInjection.cs`
       ```csharp
       using Microsoft.EntityFrameworkCore;
       using Microsoft.Extensions.Configuration;
       using Microsoft.Extensions.DependencyInjection;
       using SignaturPortal.Domain.Interfaces;
       using SignaturPortal.Infrastructure.Data;
       using SignaturPortal.Infrastructure.Repositories;

       namespace SignaturPortal.Infrastructure;

       public static class DependencyInjection
       {
           /// <summary>
           /// Registers Infrastructure layer services: EF Core DbContextFactory, repositories, UoW.
           /// </summary>
           public static IServiceCollection AddInfrastructure(
               this IServiceCollection services,
               IConfiguration configuration)
           {
               // EF Core with IDbContextFactory for Blazor Server circuit safety
               services.AddDbContextFactory<SignaturDbContext>(options =>
                   options.UseSqlServer(
                       configuration.GetConnectionString("SignaturAnnoncePortal"),
                       sqlOptions => sqlOptions.MigrationsAssembly(typeof(SignaturDbContext).Assembly.FullName)));

               // Unit of Work (creates its own DbContext via factory)
               services.AddScoped<IUnitOfWork, UnitOfWork>();

               return services;
           }
       }
       ```

    8. Update Program.cs in Web project to call AddInfrastructure:
       Add `using SignaturPortal.Infrastructure;` and call `builder.Services.AddInfrastructure(builder.Configuration);` before `var app = builder.Build();`.
       Place it after the System.Web Adapters registration (if Plan 02 has already run) or after the Blazor Services registration.

    NOTES:
    - The MigrationsAssembly in AddDbContextFactory is a pattern requirement for EF Core but we will NEVER run migrations. This is safe to include.
    - If Application layer needs to reference entity types for mapping, move the mapping files to Infrastructure layer where both entity types and DTOs are accessible. The Application layer should only define DTOs and interfaces.
  </action>
  <verify>
    Run `dotnet build SignaturPortal.sln` -- must compile cleanly with all repository, UoW, DTO, and DI code.
    Verify:
    - Domain layer .csproj has NO reference to EF Core packages (only defines interfaces)
    - Infrastructure layer .csproj references EF Core packages
    - DependencyInjection.cs registers AddDbContextFactory and AddScoped<IUnitOfWork>
    - Program.cs calls AddInfrastructure

    If the database is available, optionally verify data access works by running the app and checking no startup exceptions related to EF Core. (The app does not need to query data yet -- just confirm DI registration succeeds.)
  </verify>
  <done>EF Core scaffolded with entity classes. IDbContextFactory registered for circuit-safe access. Generic Repository and Unit of Work implemented in Infrastructure. Client DTO defined in Application. Mapping extensions created. DI wired up via AddInfrastructure. Domain layer has zero EF Core dependency. Solution builds cleanly.</done>
</task>

</tasks>

<verification>
1. `dotnet build SignaturPortal.sln` compiles all projects including EF Core entities and repositories
2. Domain layer has NO EF Core NuGet references and NO Infrastructure project references
3. Infrastructure/Data/SignaturDbContext.cs is scaffolded (auto-generated, partial class)
4. Infrastructure/Data/SignaturDbContext.Custom.cs has CurrentSiteId and CurrentClientId properties
5. Domain/Interfaces/ contains IRepository.cs and IUnitOfWork.cs
6. Infrastructure/Repositories/ contains Repository.cs and UnitOfWork.cs
7. Application/DTOs/ contains at least ClientDto.cs
8. Program.cs calls AddInfrastructure to register EF Core and repositories
</verification>

<success_criteria>
- EF Core can connect to existing database (no startup exceptions when database is available)
- Repository pattern provides clean abstraction over EF Core
- IDbContextFactory ensures circuit-safe database access for Blazor Server
- DTO mapping works without AutoMapper
- Domain layer maintains zero external dependencies
- All code compiles without warnings related to missing types
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-shell/01-03-SUMMARY.md`
</output>
