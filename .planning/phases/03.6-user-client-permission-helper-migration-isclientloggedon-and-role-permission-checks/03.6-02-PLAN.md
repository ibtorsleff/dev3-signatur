---
phase: 03.6-user-client-permission-helper-migration
plan: 02
type: execute
wave: 2
depends_on: ["03.6-01"]
files_modified:
  - src/SignaturPortal.Application/Interfaces/IPermissionHelper.cs
  - src/SignaturPortal.Infrastructure/Services/PermissionHelperService.cs
  - src/SignaturPortal.Web/Program.cs
  - src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor
  - src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor.cs
autonomous: true
must_haves:
  truths:
    - "IPermissionHelper provides async composite permission methods mirroring legacy PermissionHelper patterns"
    - "PermissionHelperService is registered as Scoped and uses IPermissionService + IUserSessionContext"
    - "ActivityList hides ClientSectionName column when user is a client user (matching legacy dskClientTh visibility)"
    - "Permission flags are loaded in OnInitializedAsync, not in Razor markup"
  artifacts:
    - path: "src/SignaturPortal.Application/Interfaces/IPermissionHelper.cs"
      provides: "Composite permission check interface"
      contains: "IPermissionHelper"
    - path: "src/SignaturPortal.Infrastructure/Services/PermissionHelperService.cs"
      provides: "Async composite permission implementation"
      contains: "PermissionHelperService"
  key_links:
    - from: "src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor.cs"
      to: "src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs"
      via: "Inject IUserSessionContext, read IsClientUser in OnInitializedAsync"
      pattern: "Session\\.IsClientUser"
    - from: "src/SignaturPortal.Infrastructure/Services/PermissionHelperService.cs"
      to: "src/SignaturPortal.Application/Interfaces/IPermissionService.cs"
      via: "HasPermissionAsync calls using PortalPermission enum"
      pattern: "PortalPermission\\."
    - from: "src/SignaturPortal.Web/Program.cs"
      to: "src/SignaturPortal.Infrastructure/Services/PermissionHelperService.cs"
      via: "DI registration as Scoped"
      pattern: "AddScoped.*IPermissionHelper.*PermissionHelperService"
---

<objective>
Create IPermissionHelper service with composite permission methods and apply IsClientUser to ActivityList column visibility.

Purpose: Provides the composite permission helper pattern (mirroring legacy PermissionHelper static methods) as a DI-friendly async service, and applies the first concrete usage -- hiding the ClientSection column for client users in the activity list.
Output: IPermissionHelper interface + PermissionHelperService implementation, ActivityList updated with permission-aware column visibility.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.6-user-client-permission-helper-migration-isclientloggedon-and-role-permission-checks/03.6-RESEARCH.md
@.planning/phases/03.6-user-client-permission-helper-migration-isclientloggedon-and-role-permission-checks/03.6-01-SUMMARY.md
@src/SignaturPortal.Application/Interfaces/IPermissionService.cs
@src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
@src/SignaturPortal.Application/Authorization/PortalPermission.cs
@src/SignaturPortal.Infrastructure/Services/PermissionService.cs
@src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor
@src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPermissionHelper interface and PermissionHelperService</name>
  <files>
    src/SignaturPortal.Application/Interfaces/IPermissionHelper.cs
    src/SignaturPortal.Infrastructure/Services/PermissionHelperService.cs
    src/SignaturPortal.Web/Program.cs
  </files>
  <action>
1. Create `src/SignaturPortal.Application/Interfaces/IPermissionHelper.cs`:

   ```csharp
   namespace SignaturPortal.Application.Interfaces;

   /// <summary>
   /// Composite permission checks mirroring legacy PermissionHelper static methods.
   /// All methods are async because they query permissions via IPermissionService (EF Core).
   /// Load results in OnInitializedAsync, store in component bool fields, use in Razor markup.
   /// </summary>
   public interface IPermissionHelper
   {
       // Ad Portal
       Task<bool> UserCanAccessAdPortalAsync(CancellationToken ct = default);
       Task<bool> UserHasAdminAccessAsync(CancellationToken ct = default);

       // Recruitment Portal
       Task<bool> UserCanAccessRecruitmentAsync(CancellationToken ct = default);
       Task<bool> UserCanAccessRecruitmentAdminAsync(CancellationToken ct = default);
       Task<bool> UserCanAccessRecruitmentDraftActivitiesAsync(CancellationToken ct = default);
       Task<bool> UserCanAccessCandidateDetailsAsync(CancellationToken ct = default);
       Task<bool> UserCanAccessCandidateNotesAsync(CancellationToken ct = default);
       Task<bool> UserCanAccessActivitiesUserNotMemberOfAsync(CancellationToken ct = default);
       Task<bool> UserCanCreateActivityAsync(CancellationToken ct = default);
   }
   ```

   Include only methods needed for current and next-phase features (activity list, activity detail, Phase 4 write ops). More methods will be added incrementally as needed.

2. Create `src/SignaturPortal.Infrastructure/Services/PermissionHelperService.cs`:

   ```csharp
   using SignaturPortal.Application.Authorization;
   using SignaturPortal.Application.Interfaces;

   namespace SignaturPortal.Infrastructure.Services;

   /// <summary>
   /// Composite permission helper mirroring legacy PermissionHelper.
   /// Registered as Scoped (uses scoped IUserSessionContext and IPermissionService).
   /// IPermissionService already caches permissions per-request, so multiple HasPermissionAsync
   /// calls within the same scope are efficient (single DB query, then set lookups).
   /// </summary>
   public class PermissionHelperService : IPermissionHelper
   {
       private readonly IPermissionService _permissionService;
       private readonly IUserSessionContext _session;

       public PermissionHelperService(IPermissionService permissionService, IUserSessionContext session)
       {
           _permissionService = permissionService;
           _session = session;
       }

       private async Task<bool> HasPermissionAsync(PortalPermission permission, CancellationToken ct)
       {
           if (!_session.IsInitialized || string.IsNullOrEmpty(_session.UserName))
               return false;
           return await _permissionService.HasPermissionAsync(_session.UserName, (int)permission, ct);
       }

       // --- Ad Portal ---

       public async Task<bool> UserCanAccessAdPortalAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.AdPortalAccess, ct);

       public async Task<bool> UserHasAdminAccessAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.AdPortalAccess, ct)
              && await HasPermissionAsync(PortalPermission.AdPortalAdminAccess, ct);

       // --- Recruitment Portal ---

       public async Task<bool> UserCanAccessRecruitmentAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.RecruitmentPortalRecruitmentAccess, ct);

       public async Task<bool> UserCanAccessRecruitmentAdminAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.RecruitmentPortalRecruitmentAccess, ct)
              && await HasPermissionAsync(PortalPermission.RecruitmentPortalAdminAccess, ct);

       public async Task<bool> UserCanAccessRecruitmentDraftActivitiesAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.RecruitmentPortalViewDraftActivities, ct)
              || await HasPermissionAsync(PortalPermission.RecruitmentPortalEditDraftActivities, ct);

       public async Task<bool> UserCanAccessCandidateDetailsAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.RecruitmentPortalRecruitmentAccess, ct)
              && (await HasPermissionAsync(PortalPermission.RecruitmentPortalViewCandidateDetails, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalCandidateEvaluation, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalEditCandidate, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalViewCandidateNotes, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalCreateCandidateNote, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalCandidateNoteCanDeleteOtherUsersNote, ct));

       public async Task<bool> UserCanAccessCandidateNotesAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.RecruitmentPortalRecruitmentAccess, ct)
              && (await HasPermissionAsync(PortalPermission.RecruitmentPortalEditCandidate, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalViewCandidateNotes, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalCreateCandidateNote, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalCandidateNoteCanDeleteOtherUsersNote, ct));

       public async Task<bool> UserCanAccessActivitiesUserNotMemberOfAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.RecruitmentPortalRecruitmentAccess, ct)
              && (await HasPermissionAsync(PortalPermission.RecruitmentPortalViewActivitiesUserNotMemberOf, ct)
                  || await HasPermissionAsync(PortalPermission.RecruitmentPortalEditActivitiesUserNotMemberOf, ct));

       public async Task<bool> UserCanCreateActivityAsync(CancellationToken ct = default)
           => await HasPermissionAsync(PortalPermission.RecruitmentPortalRecruitmentAccess, ct)
              && await HasPermissionAsync(PortalPermission.RecruitmentPortalCreateActivity, ct);
   }
   ```

   Note: The `HasPermissionAsync` private helper handles the null/uninitialized guard once, so composite methods stay clean. IPermissionService caches all permissions after the first call (scoped `_cachedPermissions` set), so the multiple `HasPermissionAsync` calls within a composite method are cheap set lookups after the initial DB query.

3. In `Program.cs`, register the service as Scoped:
   ```csharp
   builder.Services.AddScoped<IPermissionHelper, PermissionHelperService>();
   ```
   Add the necessary `using SignaturPortal.Infrastructure.Services;` if not already present. Place the registration near the existing `AddScoped<IPermissionService, PermissionService>()` line.
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.sln` -- must compile with no errors.
  </verify>
  <done>
    IPermissionHelper interface exists with 9 methods. PermissionHelperService implements all methods using IPermissionService + IUserSessionContext. Service registered as Scoped in Program.cs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply IsClientUser and permission checks to ActivityList column visibility</name>
  <files>
    src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor.cs
    src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor
  </files>
  <action>
1. In `ActivityList.razor.cs`:

   a. Add injected services:
      ```csharp
      [Inject] private IUserSessionContext Session { get; set; } = default!;
      [Inject] private IPermissionHelper PermHelper { get; set; } = default!;
      ```

   b. Add permission state fields:
      ```csharp
      private bool _isClientUser;
      private bool _canCreateActivity;
      ```

   c. Add (or convert existing `OnParametersSet` to) `OnInitializedAsync`:
      ```csharp
      protected override async Task OnInitializedAsync()
      {
          _isClientUser = Session.IsClientUser;
          _canCreateActivity = await PermHelper.UserCanCreateActivityAsync();
      }
      ```
      Keep the existing `OnParametersSet` for mode switching -- it remains synchronous and handles status changes.

   d. Update column visibility:
      - Add `_hideClientSectionColumn`: `private bool _hideClientSectionColumn => _isClientUser;`
        This matches legacy behavior: `dskClientTh` (ClientSection column / "Afdeling") is hidden when `isClientLoggedOn` (user belongs to a client).

      - Update `_hideActionsColumn` to also check permission:
        `private bool _hideActionsColumn => _currentStatus == ERActivityStatus.Draft || !_canCreateActivity;`
        This addresses the existing TODO comment about checking `RecruitmentPortalCreateActivity` permission.

2. In `ActivityList.razor`:

   a. On the ClientSectionName `<PropertyColumn>`, add `Hidden="@_hideClientSectionColumn"`:
      ```
      <PropertyColumn Property="x => x.ClientSectionName" Title="@L.GetText("ColumnClientSection")" Hidden="@_hideClientSectionColumn" HeaderStyle="width:240px;" />
      ```

   b. No other Razor changes needed -- the `_hideActionsColumn` is already bound in the template.
  </action>
  <verify>
    Run `dotnet build src/SignaturPortal.sln` -- must compile with no errors. Verify ActivityList.razor contains `Hidden="@_hideClientSectionColumn"` on the ClientSectionName column. Verify ActivityList.razor.cs injects IUserSessionContext and IPermissionHelper, loads flags in OnInitializedAsync.
  </verify>
  <done>
    ClientSectionName column is hidden for client users (matching legacy dskClientTh behavior). Copy action column respects RecruitmentPortalCreateActivity permission. All permission flags are loaded in OnInitializedAsync (async), not in Razor markup (sync).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SignaturPortal.sln` compiles with no errors
2. IPermissionHelper.cs exists in Application/Interfaces/ with async composite methods
3. PermissionHelperService.cs exists in Infrastructure/Services/ implementing IPermissionHelper
4. Program.cs registers IPermissionHelper as Scoped
5. ActivityList.razor has `Hidden="@_hideClientSectionColumn"` on ClientSectionName column
6. ActivityList.razor.cs loads _isClientUser and _canCreateActivity in OnInitializedAsync
7. No synchronous permission checks or `ClientId > 0` checks exist in Razor markup
</verification>

<success_criteria>
- IPermissionHelper is available via DI throughout the application
- PermissionHelperService mirrors legacy composite permission patterns with async methods
- ActivityList hides ClientSection column for client users (matching legacy behavior)
- ActivityList copy action respects CreateActivity permission
- All permission checks in components use pre-loaded bool fields from OnInitializedAsync
</success_criteria>

<output>
After completion, create `.planning/phases/03.6-user-client-permission-helper-migration-isclientloggedon-and-role-permission-checks/03.6-02-SUMMARY.md`
</output>
