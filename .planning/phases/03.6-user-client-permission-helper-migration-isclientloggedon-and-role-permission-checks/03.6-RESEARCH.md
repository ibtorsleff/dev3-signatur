# Phase 03.6: User/Client Permission Helper Migration - Research

**Researched:** 2026-02-17
**Domain:** Authorization, permission checking, user type classification (client vs internal)
**Confidence:** HIGH

## Summary

This phase migrates the legacy `PermissionHelper` class and the pervasive `isClientLoggedOn` pattern from the ASP.NET WebForms app to the Blazor Server app. The legacy system has two distinct authorization concepts that need to be brought to Blazor:

1. **User type classification** (`isClientLoggedOn` / `UserIsClient`): A boolean check that determines whether the current user is a "client user" (customer-facing, `ClientId > 0`) vs a Signatur internal user (consultant, DTP). This is used in 51+ legacy files for UI visibility, data filtering, URL routing, and feature gating.

2. **Composite permission helpers**: The legacy `PermissionHelper` class (706 lines) contains ~40 static helper methods that combine multiple `UserHasPermission` checks with business logic (client feature flags, role-based overrides). The Blazor app already has a working `IPermissionService` and `PermissionHandler` that query the same DB tables, but lacks the composite helper methods and the `isClientLoggedOn` concept.

The Blazor app already has all the infrastructure needed: `IUserSessionContext` provides `ClientId`, `IPermissionService.HasPermissionAsync` queries permissions via the same join path as legacy, and `PermissionHandler` + `PermissionRequirement` drive ASP.NET Core authorization policies. What's missing is: (a) a simple `IsClientUser` property on the session context, (b) a complete `Permission` enum matching the legacy enum's 90+ values, and (c) composite helper methods that mirror the legacy `PermissionHelper.UserCanAccess*` methods for use in Blazor components and services.

**Primary recommendation:** Add `IsClientUser` to `IUserSessionContext`, expand the `ERecruitmentPermission` enum into a full `PortalPermission` enum matching the legacy values, and create an `IPermissionHelper` service with async composite methods mirroring the legacy `PermissionHelper` -- all following the existing Clean Architecture patterns already established in the codebase.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| ASP.NET Core Authorization | .NET 10 | Policy-based auth with `[Authorize]` | Already in use (`PermissionHandler`, `PermissionRequirement`) |
| EF Core | 9.x | Permission queries via `IDbContextFactory` | Already in use (`PermissionService`) |
| System.Web Adapters | 2.3.0 | Session sharing for user context | Already in use (`UserSessionContext`) |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `AuthorizeView` (Blazor) | .NET 10 | Conditional rendering based on policies | For UI element visibility gating |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom `IPermissionHelper` service | Claims-based auth | Claims require mapping all permissions to claims at login time; session-based approach is simpler given the legacy integration and already works |
| Enum-based permission IDs | String-based policy names | Enum gives compile-time safety and matches legacy pattern exactly |

## Architecture Patterns

### Recommended Project Structure
```
src/
+-- SignaturPortal.Application/
|   +-- Authorization/
|   |   +-- PortalPermission.cs          # Full permission enum (replace ERecruitmentPermission)
|   +-- Interfaces/
|       +-- IUserSessionContext.cs        # Add IsClientUser property
|       +-- IPermissionService.cs         # Already exists (no changes needed)
|       +-- IPermissionHelper.cs          # NEW: composite permission check interface
+-- SignaturPortal.Infrastructure/
|   +-- Authorization/
|   |   +-- PermissionHandler.cs          # Already exists (no changes needed)
|   |   +-- PermissionRequirement.cs      # Already exists (no changes needed)
|   +-- Services/
|       +-- PermissionService.cs          # Already exists (no changes needed)
|       +-- PermissionHelper.cs           # NEW: implements IPermissionHelper
+-- SignaturPortal.Web/
    +-- Services/
        +-- UserSessionContext.cs          # Add IsClientUser computed property
```

### Pattern 1: IsClientUser on IUserSessionContext
**What:** Add `bool IsClientUser` to `IUserSessionContext` and compute it in `UserSessionContext`
**When to use:** Anywhere the legacy code checks `isClientLoggedOn`
**Example:**
```csharp
// In IUserSessionContext (Application layer)
public interface IUserSessionContext
{
    // ... existing properties ...
    bool IsClientUser { get; }  // true when ClientId > 0 (matches legacy PermissionHelper.UserIsClient)
}

// In UserSessionContext (Web layer)
public bool IsClientUser => ClientId.HasValue && ClientId.Value > 0;
```

### Pattern 2: Full Permission Enum
**What:** Replace `ERecruitmentPermission` (6 values) with `PortalPermission` (90+ values) matching legacy `PermissionHelper.Permission` exactly
**When to use:** All permission checks in the Blazor app
**Example:**
```csharp
// In Application/Authorization/PortalPermission.cs
public enum PortalPermission
{
    GeneralCreateEditServiceMessage = 100,
    AdPortalAdminAccess = 1000,
    AdPortalAccess = 1050,
    // ... all 90+ values from legacy PermissionHelper.Permission ...
    RecruitmentPortalRecruitmentAccess = 2000,
    OnboardingPortalOnboardingAccess = 3000,
    AdPortalRecruitmentSpecialAdministratorActions = 9000,
}
```

### Pattern 3: Composite Permission Helper Service
**What:** An async service that mirrors the legacy `PermissionHelper` static methods but uses `IPermissionService` and `IUserSessionContext`
**When to use:** Complex permission checks combining multiple permissions with business logic
**Example:**
```csharp
// In Application/Interfaces/IPermissionHelper.cs
public interface IPermissionHelper
{
    Task<bool> UserCanAccessAdPortalAsync(CancellationToken ct = default);
    Task<bool> UserHasAdminAccessAsync(CancellationToken ct = default);
    Task<bool> UserCanAccessRecruitmentAsync(CancellationToken ct = default);
    Task<bool> UserCanAccessCandidateDetailsAsync(CancellationToken ct = default);
    // ... mirror legacy PermissionHelper methods as needed ...
}

// In Infrastructure/Services/PermissionHelper.cs
public class PermissionHelperService : IPermissionHelper
{
    private readonly IPermissionService _permissionService;
    private readonly IUserSessionContext _session;

    public async Task<bool> UserCanAccessAdPortalAsync(CancellationToken ct = default)
    {
        if (!_session.IsInitialized || string.IsNullOrEmpty(_session.UserName))
            return false;
        return await _permissionService.HasPermissionAsync(
            _session.UserName, (int)PortalPermission.AdPortalAccess, ct);
    }

    public async Task<bool> UserHasAdminAccessAsync(CancellationToken ct = default)
    {
        if (!_session.IsInitialized || string.IsNullOrEmpty(_session.UserName))
            return false;
        return await _permissionService.HasPermissionAsync(
                _session.UserName, (int)PortalPermission.AdPortalAccess, ct)
            && await _permissionService.HasPermissionAsync(
                _session.UserName, (int)PortalPermission.AdPortalAdminAccess, ct);
    }
}
```

### Pattern 4: Authorization Policies for Composite Checks
**What:** Register named policies in `Program.cs` using `PermissionRequirement` for commonly used permission combinations
**When to use:** Page-level `[Authorize(Policy = "...")]` attributes
**Example:**
```csharp
// In Program.cs
builder.Services.AddAuthorizationBuilder()
    .AddPolicy("RecruitmentAccess", policy =>
        policy.Requirements.Add(new PermissionRequirement((int)PortalPermission.RecruitmentPortalRecruitmentAccess)))
    .AddPolicy("RecruitmentAdmin", policy =>
        policy.Requirements.Add(new PermissionRequirement((int)PortalPermission.RecruitmentPortalAdminAccess)))
    .AddPolicy("AdPortalAccess", policy =>
        policy.Requirements.Add(new PermissionRequirement((int)PortalPermission.AdPortalAccess)));
```

### Anti-Patterns to Avoid
- **Duplicating permission IDs as magic numbers:** Always use the `PortalPermission` enum, never `HasPermissionAsync(userName, 2000)` directly.
- **Checking ClientId directly in components:** Use `IUserSessionContext.IsClientUser` property instead of `_session.ClientId > 0` scattered through components.
- **Synchronous permission checks in Blazor render paths:** All permission checks are async DB queries; compute them in `OnInitializedAsync` or `OnParametersSetAsync`, store in component state, and use in markup.
- **Creating a static helper class:** The legacy `PermissionHelper` is static; in the Blazor app, use DI with `IPermissionHelper` for testability and proper scoping.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Permission caching | Custom cache layer | `IPermissionService` scoped caching | Already caches per-request via `_cachedPermissions` |
| Policy evaluation | Custom middleware | ASP.NET Core `IAuthorizationHandler` | Already implemented as `PermissionHandler` |
| User type detection | Complex logic | `ClientId > 0` check | Legacy `UserIsClient` is literally `aUser == null \|\| aUser.ClientId > 0` |
| Tenant-scoped role queries | Raw SQL | EF Core with global query filters | Already filters `AspnetRole` by SiteId/ClientId |

**Key insight:** The legacy `PermissionHelper.UserIsClient` has a subtlety: it returns `true` when `aUser == null` (treating anonymous/missing users as client users for safety). In the Blazor app, `IUserSessionContext.IsInitialized` already gates all permission checks, so the null-user case maps to "not authenticated" rather than "client user."

## Common Pitfalls

### Pitfall 1: Async Permission Checks in Razor Markup
**What goes wrong:** Calling `await _permissionHelper.UserCanAccessAsync()` inside `@if` blocks in .razor files fails because Razor's render tree is synchronous.
**Why it happens:** All permission checks go through EF Core and are async.
**How to avoid:** Load all needed permission flags in `OnInitializedAsync` into `bool` fields, then use those in markup.
**Warning signs:** Compiler errors about `await` in Razor expressions, or blocking with `.Result`/`.GetAwaiter().GetResult()`.

### Pitfall 2: Permission Enum Values Drifting from Database
**What goes wrong:** If someone adds a new permission to the DB `Permission` table but forgets to update the `PortalPermission` enum.
**Why it happens:** The enum is a C# copy of DB values.
**How to avoid:** Add a comment noting the source of truth is the `Permission` table. Consider a unit test that queries the DB and verifies all enum values exist.
**Warning signs:** `HasPermissionAsync` returns false for a permission that should exist.

### Pitfall 3: Confusing UserIsClient with Unauthenticated
**What goes wrong:** Legacy code treats `UserIsClient(null)` as `true`. If the Blazor code does `IsClientUser => ClientId > 0`, unauthenticated users would be `false` (not client users), which changes behavior.
**Why it happens:** Legacy null-safety pattern is inverted (null = client = most restrictive).
**How to avoid:** Gate all permission checks on `IsInitialized` first. If session is not initialized, deny access entirely (which the existing `PermissionHandler` already does).
**Warning signs:** Internal-only features visible to unauthenticated users.

### Pitfall 4: SignalR Circuit and Permission Checks
**What goes wrong:** Permission checks that depend on `IUserSessionContext` fail during SignalR interactions if the session wasn't restored.
**Why it happens:** `System.Web.HttpContext.Current.Session` is only available during SSR, not during SignalR button clicks.
**How to avoid:** `UserSessionContext.Restore()` + `SessionPersistence.razor` already handle this. Permission checks via `IPermissionService` use `IUserSessionContext.UserName` which survives circuit restoration.
**Warning signs:** Permissions working on initial load but failing after button clicks.

### Pitfall 5: Not Migrating All Required Permissions
**What goes wrong:** Only migrating the permissions used today (ERecruitmentPermission has 6 values) but Phase 4+ needs many more.
**Why it happens:** Incremental approach may miss future needs.
**How to avoid:** Migrate the full enum now (all 90+ values) even if only a subset is used immediately. The cost is trivial (one enum file) but prevents rework.

## Code Examples

### Current Legacy Pattern (for reference)
```csharp
// Legacy: C:\Dev\Dev3Org\AtlantaSignatur\Library\Security\PermissionHelper.cs
// UserIsClient checks if user has ClientId > 0 (i.e., belongs to a client org, not Signatur internal)
public static bool UserIsClient(AtlantaUser aUser)
{
    return (aUser == null || aUser.ClientId > 0);
}

// Composite check combining multiple permissions
public static bool UserCanAccessRecruitmentAdmin(AtlantaUser aUser)
{
    return UserHasPermission(Permission.RecruitmentPortalRecruitmentAccess, aUser)
        && UserHasPermission(Permission.RecruitmentPortalAdminAccess, aUser)
        && (UserCanAccessRecruitmentApplicationTemplates(aUser)
            || UserCanAccessRecruitmentMailTemplates(aUser) /* ... */);
}
```

### Existing Blazor Infrastructure (already working)
```csharp
// PermissionService queries same DB tables as legacy PermissionHelper.UserHasPermission
// Source: src/SignaturPortal.Infrastructure/Services/PermissionService.cs
var permissionIds = await db.AspnetUsers
    .Where(u => u.LoweredUserName == loweredName)
    .SelectMany(u => u.Roles)
    .Where(r => r.IsActive)
    .SelectMany(r => r.PermissionInRoles)
    .Select(pir => pir.PermissionId)
    .Distinct()
    .ToListAsync(ct);

// PermissionHandler denies if session not initialized
// Source: src/SignaturPortal.Infrastructure/Authorization/PermissionHandler.cs
if (!_session.IsInitialized || string.IsNullOrEmpty(_session.UserName))
    return; // requirement not satisfied -> access denied
```

### Blazor Component Usage Pattern
```csharp
// In a Blazor component code-behind
[Inject] private IPermissionHelper PermHelper { get; set; } = default!;
[Inject] private IUserSessionContext Session { get; set; } = default!;

private bool _isClientUser;
private bool _canAccessAdmin;

protected override async Task OnInitializedAsync()
{
    _isClientUser = Session.IsClientUser;
    _canAccessAdmin = await PermHelper.UserHasAdminAccessAsync();
}

// Then in .razor:
// @if (!_isClientUser) { <MudTd>@context.ClientName</MudTd> }
// @if (_canAccessAdmin) { <MudButton>Admin Action</MudButton> }
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Static `PermissionHelper` class with `AtlantaUser` parameter | DI-based `IPermissionHelper` with scoped `IUserSessionContext` | This phase | Testable, no static coupling |
| Sync `UserHasPermission` with raw SQL + cache | Async `HasPermissionAsync` with EF Core + scoped caching | Phase 2 | Already implemented |
| `ERecruitmentPermission` enum (6 values) | `PortalPermission` enum (90+ values) | This phase | Full coverage for all portals |

**Deprecated/outdated:**
- `ERecruitmentPermission`: Will be replaced by the complete `PortalPermission` enum. All references should be updated.

## Open Questions

1. **Which composite helpers are needed immediately vs later?**
   - What we know: The full legacy `PermissionHelper` has ~40 methods. Only a few are needed right now for Phase 3.x features (activity list column visibility, nav tab visibility).
   - What's unclear: Exactly which methods are needed for Phase 4 (write operations).
   - Recommendation: Create the `IPermissionHelper` interface with the methods currently needed, and add more as Phase 4 planning identifies them. Migrate the full enum now since it's cheap.

2. **Client feature flag checks (ClientHlp methods)**
   - What we know: Many legacy composite permission methods also check `ClientHlp.ClientRecruitmentEnabled()`, `ClientHlp.ClientQuestionnairesEnabled()`, etc. These are client-level feature toggles stored in a separate config table.
   - What's unclear: Whether these feature flags need to be migrated in this phase or deferred.
   - Recommendation: Defer feature flag migration. Focus this phase on permission checks and `IsClientUser`. Feature flags can be added to `IPermissionHelper` methods incrementally.

3. **UserType enum (DTP, Consultant, etc.)**
   - What we know: Legacy `PermissionHelper` has methods like `UserIsDTP()` that check `aUser.UserType`. `UserType` is stored in the XML `ObjectData` column of the `[User]` table, not as a direct column.
   - What's unclear: Whether any currently-migrated Blazor features need `UserType` checks.
   - Recommendation: Defer `UserType` migration unless a specific feature needs it. `IsClientUser` (from `ClientId > 0`) covers the most common check. `UserType` parsing from XML would require additional infrastructure.

## Sources

### Primary (HIGH confidence)
- Legacy `PermissionHelper.cs`: `C:\Dev\Dev3Org\AtlantaSignatur\Library\Security\PermissionHelper.cs` - Full source read, 706 lines, all methods analyzed
- Legacy `AtlantaUser`: `C:\Dev\Dev3Org\AtlantaSignatur\Library\GenericObjects\GenericObjects.cs` - UserType enum values (lines 5813-5821)
- Blazor `IPermissionService`: `src/SignaturPortal.Application/Interfaces/IPermissionService.cs` - Existing interface
- Blazor `PermissionService`: `src/SignaturPortal.Infrastructure/Services/PermissionService.cs` - Full implementation with scoped caching
- Blazor `PermissionHandler`: `src/SignaturPortal.Infrastructure/Authorization/PermissionHandler.cs` - ASP.NET Core authorization handler
- Blazor `IUserSessionContext`: `src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs` - Existing interface (UserId, SiteId, ClientId, UserName, UserLanguageId, IsInitialized)
- Blazor `UserSessionContext`: `src/SignaturPortal.Web/Services/UserSessionContext.cs` - Implementation with Initialize() and Restore()
- Blazor `ERecruitmentPermission`: `src/SignaturPortal.Application/Authorization/ERecruitmentPermission.cs` - Current 6-value subset
- Blazor `User` entity: `src/SignaturPortal.Infrastructure/Data/Entities/User.cs` - Has IsInternal and ClientId columns
- Legacy usage: 51 files reference `isClientLoggedOn` across master pages, controls, and page code-behinds
- `Program.cs`: Current authorization policy registration (RecruitmentAccess, RecruitmentAdmin)
- Phase 03.3 RESEARCH: Column 7 (`dskClientTh`) visibility depends on `!isClientLoggedOn`

### Secondary (MEDIUM confidence)
- None needed -- all findings from direct source code analysis

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All infrastructure already exists in the codebase, just needs extension
- Architecture: HIGH - Follows established patterns (DI services, scoped lifetime, Clean Architecture layers)
- Pitfalls: HIGH - Based on direct code analysis of legacy and Blazor implementations

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (stable -- internal codebase, no external dependency changes expected)
