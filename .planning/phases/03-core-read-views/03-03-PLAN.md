---
phase: 03-core-read-views
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/SignaturPortal.Application/DTOs/CandidateListDto.cs
  - src/SignaturPortal.Application/DTOs/CandidateDetailDto.cs
  - src/SignaturPortal.Application/DTOs/CandidateFileDto.cs
  - src/SignaturPortal.Application/Interfaces/IActivityService.cs
  - src/SignaturPortal.Infrastructure/Services/ActivityService.cs
  - src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor
  - src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor.cs
  - src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor
  - src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor.cs
  - src/SignaturPortal.Web/wwwroot/js/fileDownload.js
  - src/SignaturPortal.Web/Components/App.razor
  - src/SignaturPortal.Web/Program.cs
autonomous: true

must_haves:
  truths:
    - "User can view the list of candidates for an activity with name, email, status, and registration date"
    - "User can search candidates by name within the activity"
    - "User can open a candidate's detail to see CV and application letter content"
    - "User can download candidate attachments (CV, diplomas) as files"
    - "Candidate data respects tenant isolation -- user only sees candidates from their own activities"
  artifacts:
    - path: "src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor"
      provides: "Candidate list page with MudDataGrid"
      contains: "MudDataGrid"
    - path: "src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor"
      provides: "Candidate detail page with file download"
      contains: "downloadFileFromStream"
    - path: "src/SignaturPortal.Application/DTOs/CandidateDetailDto.cs"
      provides: "Candidate detail DTO with file list"
      contains: "CandidateDetailDto"
    - path: "src/SignaturPortal.Web/wwwroot/js/fileDownload.js"
      provides: "JavaScript interop for file download"
      contains: "downloadFileFromStream"
  key_links:
    - from: "src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor.cs"
      to: "IActivityService.GetCandidatesAsync"
      via: "DI injection + ServerData callback"
      pattern: "GetCandidatesAsync"
    - from: "src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor.cs"
      to: "IActivityService.GetCandidateFileDataAsync"
      via: "DI injection + JS interop download"
      pattern: "GetCandidateFileDataAsync"
    - from: "src/SignaturPortal.Infrastructure/Services/ActivityService.cs"
      to: "BinaryFile.FileData"
      via: "EF Core query for file content"
      pattern: "BinaryFile.*FileData"
---

<objective>
Build the Candidate List and Candidate Detail pages, including file download functionality for CVs and attachments stored in the database BinaryFile table.

Purpose: Users need to view candidates for an activity, search by name, read their CV/application letter, and download attached files. This completes APP-01 through APP-05.

Output: Working candidate list at /activities/{id}/candidates, candidate detail at /activities/{id}/candidates/{candidateId}, and file download via JS interop.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-read-views/03-RESEARCH.md
@.planning/phases/03-core-read-views/03-01-SUMMARY.md
@src/SignaturPortal.Infrastructure/Data/Entities/Ercandidate.cs
@src/SignaturPortal.Infrastructure/Data/Entities/Ercandidatefile.cs
@src/SignaturPortal.Infrastructure/Data/Entities/BinaryFile.cs
@src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
@src/SignaturPortal.Application/Interfaces/IActivityService.cs
@src/SignaturPortal.Application/DTOs/CandidateListDto.cs
@src/SignaturPortal.Infrastructure/Services/ActivityService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create candidate DTOs, extend service with candidate queries and file download</name>
  <files>
    src/SignaturPortal.Application/DTOs/CandidateListDto.cs
    src/SignaturPortal.Application/DTOs/CandidateDetailDto.cs
    src/SignaturPortal.Application/DTOs/CandidateFileDto.cs
    src/SignaturPortal.Application/Interfaces/IActivityService.cs
    src/SignaturPortal.Infrastructure/Services/ActivityService.cs
  </files>
  <action>
    **Step 1: Complete CandidateListDto**
    Update `src/SignaturPortal.Application/DTOs/CandidateListDto.cs` (stub from Plan 01):
    ```csharp
    public record CandidateListDto
    {
        public int ErcandidateId { get; init; }
        public int EractivityId { get; init; }
        public string FirstName { get; init; } = "";
        public string LastName { get; init; } = "";
        public string FullName => $"{FirstName} {LastName}".Trim();
        public string Email { get; init; } = "";
        public string Telephone { get; init; } = "";
        public string City { get; init; } = "";
        public string ZipCode { get; init; } = "";
        public DateTime RegistrationDate { get; init; }
        public int ErcandidateStatusId { get; init; }
        public string StatusName { get; init; } = "";
        public bool IsDeleted { get; init; }
        public int FileCount { get; init; }
    }
    ```

    **Step 2: Create CandidateDetailDto**
    Create `src/SignaturPortal.Application/DTOs/CandidateDetailDto.cs`:
    ```csharp
    public record CandidateDetailDto
    {
        public int ErcandidateId { get; init; }
        public int EractivityId { get; init; }
        public string FirstName { get; init; } = "";
        public string LastName { get; init; } = "";
        public string FullName => $"{FirstName} {LastName}".Trim();
        public string Email { get; init; } = "";
        public string Telephone { get; init; } = "";
        public string Address { get; init; } = "";
        public string City { get; init; } = "";
        public string ZipCode { get; init; } = "";
        public DateTime RegistrationDate { get; init; }
        public DateOnly? DateOfBirth { get; init; }
        public int ErcandidateStatusId { get; init; }
        public string StatusName { get; init; } = "";
        public bool IsDeleted { get; init; }
        public bool IsInternalCandidate { get; init; }
        public int LanguageId { get; init; }

        // Files attached to this candidate
        public List<CandidateFileDto> Files { get; init; } = new();

        // Parent activity info for breadcrumbs
        public string ActivityHeadline { get; init; } = "";
    }
    ```

    **Step 3: Create CandidateFileDto**
    Create `src/SignaturPortal.Application/DTOs/CandidateFileDto.cs`:
    ```csharp
    public record CandidateFileDto
    {
        public int BinaryFileId { get; init; }
        public string FileName { get; init; } = "";
        public int FileSize { get; init; }
        public string FileSizeFormatted => FormatFileSize(FileSize);

        private static string FormatFileSize(int bytes) => bytes switch
        {
            < 1024 => $"{bytes} B",
            < 1024 * 1024 => $"{bytes / 1024.0:F1} KB",
            _ => $"{bytes / (1024.0 * 1024.0):F1} MB"
        };
    }
    ```

    **Step 4: Extend IActivityService**
    Add these methods to the interface:
    ```csharp
    Task<GridResponse<CandidateListDto>> GetCandidatesAsync(int activityId, GridRequest request, CancellationToken ct = default);
    Task<CandidateDetailDto?> GetCandidateDetailAsync(int activityId, int candidateId, CancellationToken ct = default);
    Task<(byte[] FileData, string FileName)?> GetCandidateFileDataAsync(int candidateId, int binaryFileId, CancellationToken ct = default);
    ```

    **Step 5: Implement GetCandidatesAsync**
    In ActivityService:
    1. Create DbContext via factory, stamp tenant context
    2. Base query: `context.Ercandidates.Where(c => c.EractivityId == activityId && !c.IsDeleted)` -- global filter handles ClientId through navigation
    3. Apply name search filter from GridRequest: if a filter on "FullName" or "FirstName"/"LastName" exists, build a Where clause with `.Contains()` for both first and last name
    4. Get TotalCount
    5. Apply sorts (default: RegistrationDate descending)
    6. Apply pagination
    7. Project to CandidateListDto:
       - FileCount = subquery count from ERCandidateFile where ERCandidateId matches
       - Map ErcandidateStatusId to StatusName. The legacy ERCandidateStatus values are stored in an ERCandidateStatus table. For Phase 3, use a simplified mapping or query the status table. If the ERCandidateStatus table is not scaffolded, use a static dictionary with common statuses or simply display the numeric ID with a TODO comment for Phase 5 localization.

    **Step 6: Implement GetCandidateDetailAsync**
    In ActivityService:
    1. Create DbContext, stamp tenant
    2. Query candidate by ID within the specified activity (double-check both activityId and candidateId match)
    3. Include/project the candidate's files from ERCandidateFile joined with BinaryFile (select only BinaryFileId, FileName, FileSize -- NOT FileData)
    4. Include the parent activity headline for breadcrumbs
    5. Return null if not found or cross-tenant

    **Step 7: Implement GetCandidateFileDataAsync**
    In ActivityService:
    1. Create DbContext, stamp tenant
    2. Verify the candidate belongs to the user's tenant (join ERCandidateFile -> ERCandidate -> ERActivity, check ClientId via global filter)
    3. Query BinaryFile table for the specific BinaryFileId, selecting FileName and FileData (byte[])
    4. IMPORTANT: Only load FileData for the one specific file, never in bulk. The query should be:
       ```csharp
       var file = await context.Set<BinaryFile>()
           .Where(bf => bf.BinaryFileId == binaryFileId)
           .Select(bf => new { bf.FileData, bf.FileName })
           .FirstOrDefaultAsync(ct);
       ```
    5. Verify the file is actually linked to the candidate (security check): join through ERCandidateFile to confirm the candidateId owns this binaryFileId
    6. Return null if not found or unauthorized
    7. Return tuple of (byte[] FileData, string FileName)

    **Step 8: Verify build**
    Run `dotnet build` and fix any compilation errors.
  </action>
  <verify>
    - `dotnet build SignaturPortal.slnx` compiles with 0 errors
    - IActivityService has GetCandidatesAsync, GetCandidateDetailAsync, GetCandidateFileDataAsync
    - ActivityService implements all three methods with tenant-scoped queries
    - GetCandidateFileDataAsync verifies file ownership before returning data
  </verify>
  <done>
    CandidateListDto, CandidateDetailDto, CandidateFileDto fully defined. ActivityService extended with candidate list query (paginated, filterable by name), candidate detail query (with files metadata, no FileData), and file download query (loads single file's binary data after ownership verification).
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Candidate List page, Candidate Detail page, and file download</name>
  <files>
    src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor
    src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor.cs
    src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor
    src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor.cs
    src/SignaturPortal.Web/wwwroot/js/fileDownload.js
    src/SignaturPortal.Web/Components/App.razor
    src/SignaturPortal.Web/Program.cs
  </files>
  <action>
    **Step 1: Create file download JavaScript interop**
    Create `src/SignaturPortal.Web/wwwroot/js/fileDownload.js`:
    ```javascript
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    };
    ```

    Add the script reference to App.razor (before closing body tag):
    ```html
    <script src="js/fileDownload.js"></script>
    ```

    **Step 2: Configure SignalR for file downloads**
    In Program.cs, increase SignalR max message size to handle file downloads:
    ```csharp
    builder.Services.AddRazorComponents()
        .AddInteractiveServerComponents()
        .AddHubOptions(options =>
        {
            options.MaximumReceiveMessageSize = 10 * 1024 * 1024; // 10 MB
        });
    ```
    NOTE: Check the actual API. In .NET 10, it might be configured via `AddServerSideBlazor()` or the `AddInteractiveServerComponents()` chain. Find the correct configuration point for MaximumReceiveMessageSize and use it. If it's via `builder.Services.Configure<HubOptions>()`, use that pattern instead.

    **Step 3: Create CandidateList.razor page**
    Route: `@page "/activities/{ActivityId:int}/candidates"`
    Authorize: `@attribute [Authorize(Policy = "RecruitmentAccess")]`

    Layout:
    ```razor
    <PageTitle>Candidates</PageTitle>

    <MudBreadcrumbs Items="_breadcrumbs" />

    <!-- Search bar -->
    <MudTextField @bind-Value="_searchString"
                  Placeholder="Search by name..."
                  Adornment="Adornment.Start"
                  AdornmentIcon="@Icons.Material.Filled.Search"
                  Immediate="true"
                  DebounceInterval="300"
                  OnDebounceIntervalElapsed="OnSearchChanged" />

    <MudDataGrid T="CandidateListDto"
                 @ref="_dataGrid"
                 ServerData="LoadServerData"
                 Sortable="true"
                 Hover="true"
                 Dense="true"
                 RowClick="OnRowClick"
                 RowStyle="cursor: pointer;">
        <Columns>
            <PropertyColumn Property="x => x.FullName" Title="Name" />
            <PropertyColumn Property="x => x.Email" Title="Email" />
            <PropertyColumn Property="x => x.Telephone" Title="Phone" />
            <PropertyColumn Property="x => x.City" Title="City" />
            <PropertyColumn Property="x => x.RegistrationDate" Title="Applied" Format="yyyy-MM-dd" />
            <PropertyColumn Property="x => x.StatusName" Title="Status" />
            <PropertyColumn Property="x => x.FileCount" Title="Files" Sortable="false" />
            <TemplateColumn Title="" Sortable="false">
                <CellTemplate>
                    <MudIconButton Icon="@Icons.Material.Filled.Visibility"
                                   Size="Size.Small"
                                   OnClick="@(() => NavigateToDetail(context.Item.ErcandidateId))" />
                </CellTemplate>
            </TemplateColumn>
        </Columns>
        <PagerContent>
            <MudDataGridPager T="CandidateListDto" PageSizeOptions="new int[] { 10, 25, 50 }" />
        </PagerContent>
        <NoRecordsContent>
            <MudText>No candidates found for this activity.</MudText>
        </NoRecordsContent>
    </MudDataGrid>
    ```

    **CandidateList.razor.cs code-behind:**
    ```csharp
    public partial class CandidateList
    {
        [Parameter] public int ActivityId { get; set; }
        [Inject] private IActivityService ActivityService { get; set; } = default!;
        [Inject] private NavigationManager Navigation { get; set; } = default!;

        private MudDataGrid<CandidateListDto> _dataGrid = default!;
        private string _searchString = "";
        private List<BreadcrumbItem> _breadcrumbs = new();

        protected override void OnInitialized()
        {
            _breadcrumbs = new List<BreadcrumbItem>
            {
                new("Activities", "/activities"),
                new("Activity", $"/activities/{ActivityId}"),
                new("Candidates", null, disabled: true)
            };
        }

        private async Task<GridData<CandidateListDto>> LoadServerData(GridState<CandidateListDto> state)
        {
            var request = new GridRequest
            {
                Page = state.Page,
                PageSize = state.PageSize,
                Sorts = state.SortDefinitions
                    .Select(s => new SortDefinition(s.SortBy, s.Descending))
                    .ToList()
            };

            // Add name search as a filter
            if (!string.IsNullOrWhiteSpace(_searchString))
            {
                request.Filters.Add(new FilterDefinition("FullName", "contains", _searchString));
            }

            var response = await ActivityService.GetCandidatesAsync(ActivityId, request);

            return new GridData<CandidateListDto>
            {
                Items = response.Items,
                TotalItems = response.TotalCount
            };
        }

        private async Task OnSearchChanged()
        {
            await _dataGrid.ReloadServerData();
        }

        private void NavigateToDetail(int candidateId)
        {
            Navigation.NavigateTo($"/activities/{ActivityId}/candidates/{candidateId}");
        }

        private void OnRowClick(DataGridRowClickEventArgs<CandidateListDto> args)
        {
            NavigateToDetail(args.Item.ErcandidateId);
        }
    }
    ```

    **Step 4: Create CandidateDetail.razor page**
    Route: `@page "/activities/{ActivityId:int}/candidates/{CandidateId:int}"`
    Authorize: `@attribute [Authorize(Policy = "RecruitmentAccess")]`

    Layout:
    ```razor
    <PageTitle>Candidate - @(_candidate?.FullName ?? "Loading...")</PageTitle>

    <MudBreadcrumbs Items="_breadcrumbs" />

    @if (_candidate == null && !_notFound)
    {
        <MudProgressCircular Indeterminate="true" />
    }
    else if (_notFound)
    {
        <MudAlert Severity="Severity.Warning">Candidate not found.</MudAlert>
    }
    else
    {
        <!-- Candidate Info Card -->
        <MudCard Class="mb-4">
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h5">@_candidate.FullName</MudText>
                    <MudChip T="string" Size="Size.Small">@_candidate.StatusName</MudChip>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                <MudGrid>
                    <MudItem xs="12" md="6">
                        <MudSimpleTable Dense="true" Hover="true">
                            <tbody>
                                <tr><td><strong>Email</strong></td><td>@_candidate.Email</td></tr>
                                <tr><td><strong>Phone</strong></td><td>@_candidate.Telephone</td></tr>
                                <tr><td><strong>Address</strong></td><td>@_candidate.Address</td></tr>
                                <tr><td><strong>City</strong></td><td>@_candidate.ZipCode @_candidate.City</td></tr>
                                <tr><td><strong>Date of Birth</strong></td><td>@_candidate.DateOfBirth?.ToString("yyyy-MM-dd")</td></tr>
                                <tr><td><strong>Applied</strong></td><td>@_candidate.RegistrationDate.ToString("yyyy-MM-dd HH:mm")</td></tr>
                                <tr><td><strong>Internal Candidate</strong></td><td>@(_candidate.IsInternalCandidate ? "Yes" : "No")</td></tr>
                            </tbody>
                        </MudSimpleTable>
                    </MudItem>
                </MudGrid>
            </MudCardContent>
        </MudCard>

        <!-- Attachments Card -->
        <MudCard>
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">
                        Attachments
                        <MudChip T="string" Size="Size.Small">@_candidate.Files.Count</MudChip>
                    </MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                @if (_candidate.Files.Any())
                {
                    <MudSimpleTable Dense="true" Hover="true" Striped="true">
                        <thead>
                            <tr>
                                <th>File Name</th>
                                <th>Size</th>
                                <th>Download</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var file in _candidate.Files)
                            {
                                <tr>
                                    <td>@file.FileName</td>
                                    <td>@file.FileSizeFormatted</td>
                                    <td>
                                        <MudIconButton Icon="@Icons.Material.Filled.Download"
                                                       Size="Size.Small"
                                                       Color="Color.Primary"
                                                       Disabled="_downloadingFileId == file.BinaryFileId"
                                                       OnClick="@(() => DownloadFileAsync(file.BinaryFileId, file.FileName))" />
                                        @if (_downloadingFileId == file.BinaryFileId)
                                        {
                                            <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                        }
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </MudSimpleTable>
                }
                else
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">No attachments.</MudText>
                }
            </MudCardContent>
        </MudCard>
    }
    ```

    **CandidateDetail.razor.cs code-behind:**
    ```csharp
    public partial class CandidateDetail
    {
        [Parameter] public int ActivityId { get; set; }
        [Parameter] public int CandidateId { get; set; }
        [Inject] private IActivityService ActivityService { get; set; } = default!;
        [Inject] private NavigationManager Navigation { get; set; } = default!;
        [Inject] private IJSRuntime JS { get; set; } = default!;
        [Inject] private ISnackbar Snackbar { get; set; } = default!;

        private CandidateDetailDto? _candidate;
        private bool _notFound;
        private int? _downloadingFileId;
        private List<BreadcrumbItem> _breadcrumbs = new();

        protected override async Task OnInitializedAsync()
        {
            _breadcrumbs = new List<BreadcrumbItem>
            {
                new("Activities", "/activities"),
                new("Activity", $"/activities/{ActivityId}"),
                new("Candidates", $"/activities/{ActivityId}/candidates"),
                new("Detail", null, disabled: true)
            };

            _candidate = await ActivityService.GetCandidateDetailAsync(ActivityId, CandidateId);

            if (_candidate == null)
            {
                _notFound = true;
            }
            else
            {
                _breadcrumbs[3] = new BreadcrumbItem(_candidate.FullName, null, disabled: true);
            }
        }

        private async Task DownloadFileAsync(int binaryFileId, string fileName)
        {
            try
            {
                _downloadingFileId = binaryFileId;
                StateHasChanged();

                var result = await ActivityService.GetCandidateFileDataAsync(CandidateId, binaryFileId);

                if (result == null)
                {
                    Snackbar.Add("File not found.", Severity.Error);
                    return;
                }

                var (fileData, actualFileName) = result.Value;

                using var stream = new MemoryStream(fileData);
                using var streamRef = new DotNetStreamReference(stream);
                await JS.InvokeVoidAsync("downloadFileFromStream", actualFileName, streamRef);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Download failed: {ex.Message}", Severity.Error);
            }
            finally
            {
                _downloadingFileId = null;
                StateHasChanged();
            }
        }
    }
    ```

    **Step 5: Verify build and page structure**
    - `dotnet build` must pass
    - Candidate list and detail pages have correct route parameters
    - File download JS interop is wired correctly
  </action>
  <verify>
    - `dotnet build SignaturPortal.slnx` compiles with 0 errors
    - CandidateList.razor has route `/activities/{ActivityId:int}/candidates`
    - CandidateDetail.razor has route `/activities/{ActivityId:int}/candidates/{CandidateId:int}`
    - fileDownload.js exists at wwwroot/js/fileDownload.js
    - App.razor includes script reference to fileDownload.js
    - CandidateDetail.razor.cs has DownloadFileAsync method using DotNetStreamReference
    - Search field in candidate list triggers server data reload
  </verify>
  <done>
    Candidate list page renders at /activities/{id}/candidates with MudDataGrid showing candidates with pagination, sorting, and name search. Candidate detail page renders at /activities/{id}/candidates/{candidateId} with candidate info and downloadable file attachments. File download uses JS interop with DotNetStreamReference to stream BinaryFile.FileData to the browser. All pages have breadcrumb navigation and handle loading/not-found states.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build SignaturPortal.slnx` -- zero errors
2. /activities/{id}/candidates shows candidate list with pagination and search
3. Searching by name filters candidates server-side
4. /activities/{id}/candidates/{candidateId} shows candidate details with files
5. Download button triggers file download via JS interop
6. Files are loaded from BinaryFile table (not streamed from filesystem)
7. Candidate data scoped to user's tenant via global query filters
8. Invalid or cross-tenant candidate IDs show "not found" message
</verification>

<success_criteria>
- User navigates from activity detail to candidate list
- Candidate list shows name, email, phone, city, applied date, status, file count
- User can search candidates by name (debounced, server-side)
- User clicks a candidate and sees full details: contact info, dates, status
- Attachments section lists all files with name, size, and download button
- Clicking download triggers browser file save dialog with correct filename
- Download shows loading spinner while in progress
- Error during download shows snackbar notification
- All data respects tenant isolation
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-read-views/03-03-SUMMARY.md`
</output>
