---
phase: 03-core-read-views
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
  - src/SignaturPortal.Web/Services/UserSessionContext.cs
  - src/SignaturPortal.Web/Components/Layout/SessionPersistence.razor
  - src/SignaturPortal.Web/Components/Layout/SessionInfo.razor
  - src/SignaturPortal.Infrastructure/Services/ActivityService.cs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Activity list loads and displays recruitment activities when session has valid ClientId"
    - "Activity list loads and displays ALL activities when session has no ClientId (null bypass)"
    - "Session values persist correctly through SSR-to-circuit handoff via PersistentComponentState"
  artifacts:
    - path: "src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs"
      provides: "Nullable int? types for UserId, SiteId, ClientId"
      contains: "int? ClientId"
    - path: "src/SignaturPortal.Web/Services/UserSessionContext.cs"
      provides: "Updated implementation with int? properties and null defaults"
      contains: "int? ClientId"
    - path: "src/SignaturPortal.Web/Components/Layout/SessionPersistence.razor"
      provides: "SessionData class with matching int? types"
      contains: "int? ClientId"
  key_links:
    - from: "src/SignaturPortal.Web/Services/UserSessionContext.cs"
      to: "src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs"
      via: "ActivityService stamps context.CurrentClientId = _sessionContext.ClientId"
      pattern: "CurrentClientId.*=.*_sessionContext\\.ClientId"
---

<objective>
Fix nullable session context types so multi-tenancy query filters work correctly.

Purpose: The activity list shows no data because IUserSessionContext.ClientId is int (defaults to 0),
but SignaturDbContext.CurrentClientId is int? where null means "no filtering". When the service stamps
context.CurrentClientId = 0, the query filter matches ClientId == 0 instead of bypassing. Changing to
int? ensures uninitialized sessions pass null (bypass) and initialized sessions pass the real value.

Output: Activity list correctly loads data for the current tenant, or all data when no tenant is set.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
@src/SignaturPortal.Web/Services/UserSessionContext.cs
@src/SignaturPortal.Web/Components/Layout/SessionPersistence.razor
@src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs
@src/SignaturPortal.Infrastructure/Services/ActivityService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Change IUserSessionContext and UserSessionContext to use nullable int? for tenant IDs</name>
  <files>
    src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs
    src/SignaturPortal.Web/Services/UserSessionContext.cs
    src/SignaturPortal.Web/Components/Layout/SessionPersistence.razor
    src/SignaturPortal.Web/Components/Layout/SessionInfo.razor
  </files>
  <action>
    1. In IUserSessionContext.cs, change these properties from int to int?:
       - UserId: int? UserId { get; }
       - SiteId: int? SiteId { get; }
       - ClientId: int? ClientId { get; }
       Keep UserLanguageId as int (0 is a valid default, not used for filtering).
       Keep IsInitialized as bool.

    2. In UserSessionContext.cs, update the backing implementation:
       - Change UserId, SiteId, ClientId from int to int? (they default to null instead of 0).
       - In Initialize(): keep the pattern but assign null when session key not found:
         UserId = swSession["UserId"] is int uid ? uid : null;
         SiteId = swSession["SiteId"] is int sid ? sid : null;
         ClientId = swSession["ClientId"] is int cid ? cid : null;
       - In Restore(): change parameter types to int?, int?, int?, string, int.

    3. In SessionPersistence.razor, update the SessionData inner class:
       - Change UserId, SiteId, ClientId from int to int? in the SessionData class.
       - The Restore call already passes these values through, so the types will align.
       - PersistAsJson and TryTakeFromJson handle nullable types correctly.

    4. In SessionInfo.razor, update display to handle nulls:
       - Change display to show "N/A" when value is null:
         @(Session.UserId?.ToString() ?? "N/A")
         @(Session.SiteId?.ToString() ?? "N/A")
         @(Session.ClientId?.ToString() ?? "N/A")
  </action>
  <verify>
    Run `dotnet build` from the solution root. All projects must compile without errors.
    Grep for "int UserId" and "int SiteId" and "int ClientId" in the interface file -- should find "int?" not "int".
  </verify>
  <done>
    IUserSessionContext exposes int? for UserId, SiteId, ClientId.
    UserSessionContext defaults to null (not 0) for uninitialized sessions.
    SessionPersistence correctly persists and restores nullable values.
    The project compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix all service methods that stamp tenant context from session</name>
  <files>
    src/SignaturPortal.Infrastructure/Services/ActivityService.cs
  </files>
  <action>
    Review ActivityService.cs -- it stamps tenant context in 5 places:
      context.CurrentSiteId = _sessionContext.SiteId;
      context.CurrentClientId = _sessionContext.ClientId;

    After Task 1, _sessionContext.SiteId and _sessionContext.ClientId are int?, and
    context.CurrentSiteId / context.CurrentClientId are already int?. So the assignment
    will now correctly pass null when session is uninitialized, triggering the
    "CurrentClientId == null" bypass in the query filter.

    Verify that no explicit conversion or cast is needed -- both sides are int? so
    the assignment should work directly. If any compilation error arises, fix it.

    Also check PermissionService.cs for the same pattern and fix if needed.
    Also check TenantSaveChangesInterceptor.cs and UnitOfWork.cs for usage of
    _sessionContext.SiteId or _sessionContext.ClientId and update any int comparisons
    to handle the nullable type (e.g., .HasValue checks, ?? operators).

    Search the entire solution for references to IUserSessionContext.UserId,
    IUserSessionContext.SiteId, IUserSessionContext.ClientId and fix any compilation
    issues caused by the int-to-int? change. Common patterns to look for:
    - Direct int assignment: var x = session.ClientId; -- x is now int?, may need .Value or ?? 0
    - Equality comparisons: if (session.ClientId == someInt) -- works fine with int?
    - Method calls expecting int: SomeMethod(session.ClientId) -- may need .Value or ?? default

    Do NOT change the DbContext.CurrentSiteId/CurrentClientId types -- they are already int?.
  </action>
  <verify>
    Run `dotnet build` from the solution root. All projects must compile without errors or warnings.
    Run `dotnet test` if any tests exist that reference session context.
  </verify>
  <done>
    All references to IUserSessionContext.UserId/SiteId/ClientId compile correctly with int?.
    ActivityService stamps null (not 0) when session is uninitialized, causing query filter bypass.
    When session IS initialized with real values, those values flow through correctly.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes for the entire solution
2. With a valid session (ClientId has a value), ActivityService stamps context.CurrentClientId = the real value, and query filter returns only that tenant's data
3. With no session (ClientId is null), ActivityService stamps context.CurrentClientId = null, and query filter bypasses (returns all data -- appropriate for admin/debug scenarios)
4. SessionPersistence correctly round-trips nullable values through PersistentComponentState
</verification>

<success_criteria>
- Activity list page loads and displays recruitment activities (UAT test 1 passes)
- Pagination, sorting, row click all work because data is now present (UAT tests 2-4 unblocked)
- Session values survive the SSR-to-SignalR circuit transition
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-read-views/03-05-SUMMARY.md`
</output>
