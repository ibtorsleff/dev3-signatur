---
phase: 03-core-read-views
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SignaturPortal.Web/Components/Pages/Activities/ActivityDetail.razor.cs
  - src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor.cs
  - src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor.cs
  - src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor.cs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Navigating to /activities/999999 shows 'Activity not found' alert instead of crashing the circuit"
    - "Any service exception during page load is caught and displayed as a user-friendly error"
    - "The Blazor circuit remains responsive after encountering an error"
  artifacts:
    - path: "src/SignaturPortal.Web/Components/Pages/Activities/ActivityDetail.razor.cs"
      provides: "Try-catch around OnInitializedAsync service call"
      contains: "catch"
    - path: "src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor.cs"
      provides: "Try-catch around OnInitializedAsync service call"
      contains: "catch"
  key_links:
    - from: "src/SignaturPortal.Web/Components/Pages/Activities/ActivityDetail.razor.cs"
      to: "src/SignaturPortal.Infrastructure/Services/ActivityService.cs"
      via: "try-catch wrapping GetActivityDetailAsync call"
      pattern: "try.*GetActivityDetailAsync.*catch"
---

<objective>
Add error handling to all Blazor page lifecycle methods that call services.

Purpose: Navigating to /activities/999999 crashes the Blazor circuit because ActivityDetail.razor.cs
has no try-catch around the service call in OnInitializedAsync. Any unhandled exception in a Blazor
Server lifecycle method kills the SignalR circuit, leaving the page unresponsive. This fix wraps all
service calls in page lifecycle methods with try-catch, setting appropriate error state instead of
letting exceptions propagate.

Output: All activity/candidate pages handle service errors gracefully without circuit death.
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/SignaturPortal.Web/Components/Pages/Activities/ActivityDetail.razor.cs
@src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor.cs
@src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor.cs
@src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add try-catch error handling to ActivityDetail and CandidateDetail page lifecycle methods</name>
  <files>
    src/SignaturPortal.Web/Components/Pages/Activities/ActivityDetail.razor.cs
    src/SignaturPortal.Web/Components/Pages/Activities/CandidateDetail.razor.cs
  </files>
  <action>
    1. In ActivityDetail.razor.cs, wrap the OnInitializedAsync body in try-catch:

       Add a private string? _errorMessage field.

       protected override async Task OnInitializedAsync()
       {
           _breadcrumbs = new List&lt;BreadcrumbItem&gt;
           {
               new("Activities", "/activities"),
               new("Detail", null, disabled: true)
           };

           try
           {
               _activity = await ActivityService.GetActivityDetailAsync(ActivityId);

               if (_activity == null)
               {
                   _notFound = true;
               }
               else
               {
                   _breadcrumbs[1] = new BreadcrumbItem(_activity.Headline, null, disabled: true);
               }
           }
           catch (Exception ex)
           {
               _notFound = true;
               _errorMessage = "An error occurred while loading the activity. Please try again.";
               // Log to ILogger if available, or just swallow to keep circuit alive
           }
       }

    2. In ActivityDetail.razor, update the "not found" display section to also show _errorMessage
       when it is set. The existing _notFound check should already show a message. If the razor file
       shows a MudAlert for _notFound, keep that pattern. If _errorMessage is set, show a different
       MudAlert with Severity.Error and the _errorMessage text. Example:

       @if (_errorMessage is not null)
       {
           <MudAlert Severity="Severity.Error">@_errorMessage</MudAlert>
       }
       else if (_notFound)
       {
           <MudAlert Severity="Severity.Warning">Activity not found.</MudAlert>
       }

    3. In CandidateDetail.razor.cs, apply the same pattern:

       Add a private string? _errorMessage field.
       Add a private bool _notFound field (if not already present).

       Wrap the OnInitializedAsync service call in try-catch:

       try
       {
           _candidate = await ActivityService.GetCandidateDetailAsync(ActivityId, CandidateId);
           _loading = false;
           // ... existing breadcrumb logic
       }
       catch (Exception ex)
       {
           _loading = false;
           _notFound = true;
           _errorMessage = "An error occurred while loading the candidate. Please try again.";
       }

    4. In CandidateDetail.razor, add the same MudAlert pattern for _errorMessage and _notFound
       (candidate not found) display.

    NOTE: CandidateDetail already has try-catch on DownloadFileAsync (good). This fix addresses
    only the OnInitializedAsync lifecycle method which currently has no protection.
  </action>
  <verify>
    Run `dotnet build` from the solution root -- must compile without errors.
    Verify by reading ActivityDetail.razor.cs that try-catch wraps the service call.
    Verify by reading CandidateDetail.razor.cs that try-catch wraps the service call.
  </verify>
  <done>
    ActivityDetail.razor.cs catches exceptions in OnInitializedAsync and sets _notFound + _errorMessage.
    CandidateDetail.razor.cs catches exceptions in OnInitializedAsync and sets _notFound + _errorMessage.
    The Blazor circuit survives invalid IDs and service errors without becoming unresponsive.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add defensive error handling to ActivityList and CandidateList server data callbacks</name>
  <files>
    src/SignaturPortal.Web/Components/Pages/Activities/ActivityList.razor.cs
    src/SignaturPortal.Web/Components/Pages/Activities/CandidateList.razor.cs
  </files>
  <action>
    1. In ActivityList.razor.cs, wrap LoadServerData in try-catch:

       Add: [Inject] private ISnackbar Snackbar { get; set; } = default!;

       private async Task&lt;GridData&lt;ActivityListDto&gt;&gt; LoadServerData(GridState&lt;ActivityListDto&gt; state)
       {
           try
           {
               // ... existing request building and service call ...
           }
           catch (Exception ex)
           {
               Snackbar.Add("Error loading activities. Please refresh the page.", Severity.Error);
               return new GridData&lt;ActivityListDto&gt;
               {
                   Items = Array.Empty&lt;ActivityListDto&gt;(),
                   TotalItems = 0
               };
           }
       }

       This prevents the MudDataGrid ServerData callback from killing the circuit when the
       service throws. The user sees a snackbar error and an empty grid instead of a dead page.

    2. In CandidateList.razor.cs, apply the same pattern to LoadServerData:

       Add: [Inject] private ISnackbar Snackbar { get; set; } = default!;

       Wrap in try-catch, show snackbar on error, return empty GridData.

    3. Also wrap CandidateList.OnSearchChanged in try-catch (it calls _dataGrid.ReloadServerData()
       which triggers the server data callback, but an error in ReloadServerData itself could
       propagate). However, since ReloadServerData just triggers the callback, the try-catch in
       LoadServerData should suffice. Only add try-catch to OnSearchChanged if there is logic
       beyond the ReloadServerData call.

    IMPORTANT: Add "using MudBlazor;" if not already present (it should be, since MudDataGrid is used).
    Add ISnackbar injection only -- do not add ILogger for now (keep it simple, Phase 5 will add
    proper error infrastructure).
  </action>
  <verify>
    Run `dotnet build` from the solution root -- must compile without errors.
    Verify ActivityList.razor.cs has try-catch in LoadServerData.
    Verify CandidateList.razor.cs has try-catch in LoadServerData.
  </verify>
  <done>
    All four Blazor page code-behinds have defensive error handling.
    No unhandled exception in any page lifecycle or data callback can kill the Blazor circuit.
    Users see meaningful error messages (MudAlert or Snackbar) instead of a dead page.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes for the entire solution
2. Navigating to /activities/999999 shows "Activity not found" alert, page remains interactive (UAT test 10 passes)
3. If database is unreachable, activity list shows snackbar error and empty grid (not a circuit crash)
4. All page error states display via MudAlert or Snackbar, not raw exceptions
</verification>

<success_criteria>
- /activities/999999 shows graceful "not found" message (UAT test 10 fixed -- was blocker)
- Activity list service errors show user-friendly snackbar (circuit stays alive)
- Candidate pages handle service errors the same way
- No Blazor circuit deaths from service layer exceptions
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-read-views/03-06-SUMMARY.md`
</output>
