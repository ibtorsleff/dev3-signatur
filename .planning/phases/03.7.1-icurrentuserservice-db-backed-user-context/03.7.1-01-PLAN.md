---
phase: 03.7.1-icurrentuserservice-db-backed-user-context
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SignaturPortal.Application/Interfaces/ICurrentUserService.cs
  - src/SignaturPortal.Infrastructure/Services/CurrentUserService.cs
autonomous: true
must_haves:
  truths:
    - "ICurrentUserService interface exists in the Application layer with GetCurrentUserAsync method only — no Guid? UserId shortcut property"
    - "CurrentUserService implementation lazy-loads the User entity from DB using AuthenticationStateProvider (auth cookie ClaimsPrincipal identity name)"
    - "CurrentUserService caches the User record for the Blazor circuit lifetime using _loaded bool + _cachedUser field"
    - "Build compiles without errors after adding both files"
  artifacts:
    - path: "src/SignaturPortal.Application/Interfaces/ICurrentUserService.cs"
      provides: "Contract for DB-backed current user access"
      contains: "GetCurrentUserAsync"
    - path: "src/SignaturPortal.Infrastructure/Services/CurrentUserService.cs"
      provides: "Scoped lazy-loading implementation of ICurrentUserService"
      contains: "_loaded"
  key_links:
    - from: "src/SignaturPortal.Infrastructure/Services/CurrentUserService.cs"
      to: "src/SignaturPortal.Application/Interfaces/ICurrentUserService.cs"
      via: "implements interface"
      pattern: "ICurrentUserService"
    - from: "src/SignaturPortal.Infrastructure/Services/CurrentUserService.cs"
      to: "AuthenticationStateProvider"
      via: "constructor injection, GetAuthenticationStateAsync for UserName"
      pattern: "GetAuthenticationStateAsync"
---

<objective>
Create ICurrentUserService interface and CurrentUserService implementation — the DB-backed current user abstraction.

Purpose: Provide a single, reusable point of access to the logged-in user's [User] table record. The DB lookup is keyed by UserName from AuthenticationStateProvider — the Blazor-correct equivalent of HttpContext.User.Identity.Name that works throughout the circuit lifecycle (SSR and SignalR). The auth cookie is the authoritative source, not a session value. Multiple services need the full User entity (FullName, IsInternal, UserId, etc.) and should not each implement their own DB lookup.

Output: Two new files — ICurrentUserService.cs (Application layer contract) and CurrentUserService.cs (Infrastructure layer implementation with lazy-loading + circuit-scoped caching).
</objective>

<execution_context>
@C:/Users/it/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/it/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.7.1-icurrentuserservice-db-backed-user-context/03.7.1-RESEARCH.md

<!-- Key reference files -->
@src/SignaturPortal.Infrastructure/Services/PermissionService.cs
@src/SignaturPortal.Infrastructure/Data/Entities/User.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ICurrentUserService interface in Application layer</name>
  <files>src/SignaturPortal.Application/Interfaces/ICurrentUserService.cs</files>
  <action>
Create `src/SignaturPortal.Application/Interfaces/ICurrentUserService.cs`.

FIRST: Read `src/SignaturPortal.Application/SignaturPortal.Application.csproj` to check whether Application references Infrastructure. Clean Architecture convention says it should NOT.

If Application does NOT reference Infrastructure (expected):
- The interface cannot return `SignaturPortal.Infrastructure.Data.Entities.User` directly
- Create a minimal DTO record in `src/SignaturPortal.Application/DTOs/CurrentUserDto.cs`:

```csharp
namespace SignaturPortal.Application.DTOs;

/// <summary>
/// Snapshot of the current user's [User] table record, loaded once per Blazor circuit.
/// </summary>
public record CurrentUserDto(
    Guid UserId,
    string? FullName,
    string? UserName,
    string? Email,
    bool IsInternal,
    bool Enabled,
    int SiteId,
    int? ClientId);
```

Then create the interface:

```csharp
using SignaturPortal.Application.DTOs;

namespace SignaturPortal.Application.Interfaces;

/// <summary>
/// Provides access to the currently logged-in user's DB record from the [User] table.
/// Lookup is keyed by UserName from the authenticated identity — the auth cookie is the source of truth.
/// Scoped to the Blazor circuit lifetime — data is loaded once per circuit and cached.
/// </summary>
public interface ICurrentUserService
{
    /// <summary>
    /// Lazy-loads the current user's [User] table record from the database by UserName.
    /// Returns null if session is not initialized, UserName is empty, or user not found in DB.
    /// Cached for the Blazor circuit lifetime (Scoped DI). Thread safety: not needed in Blazor Server.
    /// </summary>
    Task<CurrentUserDto?> GetCurrentUserAsync(CancellationToken ct = default);
}
```

If Application DOES reference Infrastructure (uncommon for this project):
- Return `SignaturPortal.Infrastructure.Data.Entities.User?` directly from GetCurrentUserAsync
- No DTO needed

Key naming rules (project conventions):
- Method name: `GetCurrentUserAsync` (not `GetCurrentUser` or `LoadAsync`)
- Parameter name: `ct` for CancellationToken
- No single-letter identifiers anywhere
  </action>
  <verify>
    `dotnet build src/SignaturPortal.Application/SignaturPortal.Application.csproj` — zero errors.
    File exists: `src/SignaturPortal.Application/Interfaces/ICurrentUserService.cs`.
  </verify>
  <done>
    ICurrentUserService.cs exists, compiles, defines `Task&lt;...?&gt; GetCurrentUserAsync(CancellationToken ct = default)` — no Guid? UserId property.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CurrentUserService implementation in Infrastructure layer</name>
  <files>src/SignaturPortal.Infrastructure/Services/CurrentUserService.cs</files>
  <action>
Create `src/SignaturPortal.Infrastructure/Services/CurrentUserService.cs`.

Namespace: `SignaturPortal.Infrastructure.Services`

Pattern: Mirror PermissionService caching (read `src/SignaturPortal.Infrastructure/Services/PermissionService.cs` for reference). Use `_loaded` bool flag + `_cachedUser` nullable field. The `_loaded` bool (not a null-check on `_cachedUser`) handles the case where the user exists in session but is NOT found in the [User] table — prevents an infinite retry on every call.

```csharp
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.EntityFrameworkCore;
using SignaturPortal.Application.DTOs;       // or remove if returning User entity directly
using SignaturPortal.Application.Interfaces;
using SignaturPortal.Infrastructure.Data;

namespace SignaturPortal.Infrastructure.Services;

/// <summary>
/// Provides DB-backed access to the current user's [User] table record.
/// Lazy-loads on first call and caches for the Blazor circuit lifetime (Scoped).
///
/// The Blazor-correct equivalent of HttpContext.User.Identity.Name is AuthenticationStateProvider —
/// it gives you the same ClaimsPrincipal from the auth cookie, but works throughout the circuit lifecycle.
/// </summary>
public class CurrentUserService : ICurrentUserService
{
    private readonly IDbContextFactory<SignaturDbContext> _contextFactory;
    private readonly AuthenticationStateProvider _authStateProvider;
    private CurrentUserDto? _cachedUser;   // null until loaded, also null if not found in DB
    private bool _loaded;

    public CurrentUserService(
        IDbContextFactory<SignaturDbContext> contextFactory,
        AuthenticationStateProvider authStateProvider)
    {
        _contextFactory = contextFactory;
        _authStateProvider = authStateProvider;
    }

    public async Task<CurrentUserDto?> GetCurrentUserAsync(CancellationToken ct = default)
    {
        if (_loaded)
            return _cachedUser;

        _loaded = true;

        var authState = await _authStateProvider.GetAuthenticationStateAsync();
        var userName = authState.User.Identity?.Name;

        if (string.IsNullOrEmpty(userName))
            return null;

        await using var db = await _contextFactory.CreateDbContextAsync(ct);
        // No global query filter on [User] table by design — see SignaturDbContext.Custom.cs comments.
        // User data is accessed through ERActivityMember joins (already tenant-filtered).
        var user = await db.Users
            .Where(u => u.UserName == userName)
            .FirstOrDefaultAsync(ct);

        if (user == null)
            return null;

        _cachedUser = new CurrentUserDto(
            UserId: user.UserId,
            FullName: user.FullName,
            UserName: user.UserName,
            Email: user.Email,
            IsInternal: user.IsInternal,
            Enabled: user.Enabled ?? false,
            SiteId: user.SiteId,
            ClientId: user.ClientId);

        return _cachedUser;
    }
}
```

IMPORTANT: If Task 1 returned the User entity directly (Application references Infrastructure), adjust accordingly — return `User?` type, assign `_cachedUser = user` directly, remove DTO mapping block.

Rules:
- Do NOT add locking — Blazor Server components run single-threaded per circuit
- Do NOT add a global query filter to db.Users — the User table intentionally has no filter (confirmed by SignaturDbContext.Custom.cs)
- Do NOT use `.GetAwaiter().GetResult()` anywhere
- Do NOT call GetCurrentUserAsync in the constructor
- Do NOT inject IUserSessionContext — AuthenticationStateProvider is the sole identity source
  </action>
  <verify>
    `dotnet build src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj` — zero errors.
    File exists: `src/SignaturPortal.Infrastructure/Services/CurrentUserService.cs`.
    Grep `_loaded` in CurrentUserService.cs returns a match.
    Grep `GetAuthenticationStateAsync` in CurrentUserService.cs returns a match.
  </verify>
  <done>
    CurrentUserService.cs exists, implements ICurrentUserService, uses _loaded bool caching, injects AuthenticationStateProvider, queries db.Users by userName from authState.User.Identity.Name, builds without errors.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `dotnet build C:/Users/it/Documents/Dev/CustomersAndProjects/Signatur/Dev3/src/SignaturPortal.Application/SignaturPortal.Application.csproj` — zero errors
2. `dotnet build C:/Users/it/Documents/Dev/CustomersAndProjects/Signatur/Dev3/src/SignaturPortal.Infrastructure/SignaturPortal.Infrastructure.csproj` — zero errors
3. ICurrentUserService.cs exists in Application/Interfaces/
4. CurrentUserService.cs exists in Infrastructure/Services/
5. Grep `_loaded` in CurrentUserService.cs — match present
6. Grep `GetAuthenticationStateAsync` in CurrentUserService.cs — match present
</verification>

<success_criteria>
- ICurrentUserService interface compiles in Application layer with GetCurrentUserAsync only (no Guid? UserId shortcut)
- CurrentUserService implementation compiles in Infrastructure layer, injects AuthenticationStateProvider, looks up by auth identity Name
- Lazy-loading with _loaded bool matches PermissionService pattern
- Zero build errors in both projects
</success_criteria>

<output>
After completion, create `.planning/phases/03.7.1-icurrentuserservice-db-backed-user-context/03.7.1-01-SUMMARY.md`
</output>
