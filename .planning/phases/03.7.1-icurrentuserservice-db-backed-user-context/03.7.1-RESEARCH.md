# Phase 03.7.1: ICurrentUserService — DB-Backed User Context - Research

**Researched:** 2026-02-17
**Domain:** Blazor Server scoped service design, EF Core IDbContextFactory, scoped lazy-loading pattern
**Confidence:** HIGH

## Summary

Phase 03.7 established session-based identity via `IUserSessionContext` (frozen at SSR: UserId, SiteId, ClientId, UserName, UserLanguageId). The gap this phase fills is that multiple services need the current user's **database record** — specifically the `[User]` table row that contains richer data not stored in session (FullName, IsInternal, Enabled, Email, Title, etc.).

Currently `ActivityService` has a private `GetUserGuidAsync` method that queries `aspnet_Users` by `UserName` to resolve a Guid — even though `IUserSessionContext.UserId` already holds that Guid from session. This is redundant, and the pattern will multiply as more services need user data. `ICurrentUserService` consolidates: it takes `UserId` from `IUserSessionContext` (no extra DB lookup needed) and lazy-loads the `User` entity from the `[User]` table on first access, caching it for the Blazor circuit lifetime.

The `User` entity is already scaffolded in the Infrastructure layer (`SignaturPortal.Infrastructure.Data.Entities.User`). The `SignaturDbContext` already exposes `DbSet<User> Users`. No schema changes are needed. The pattern is: define `ICurrentUserService` in Application, implement in Infrastructure, register as Scoped, and refactor `ActivityService` to use it instead of the private `GetUserGuidAsync` helper.

**Primary recommendation:** Define `ICurrentUserService` with a `GetCurrentUserAsync()` method returning the `User` entity (or null if not initialized). Register as Scoped in Infrastructure. Replace `ActivityService.GetUserGuidAsync` with `ICurrentUserService.UserId` (from session, already a Guid).

## Current Architecture (What Exists — Verified by Code Reading)

### What IUserSessionContext Provides (frozen at SSR)

```
IUserSessionContext (Scoped, SignaturPortal.Application.Interfaces)
├── UserId: Guid?          — from session["UserId"] (Guid)
├── SiteId: int?           — from session["SiteId"]
├── ClientId: int?         — from session["ClientId"]
├── UserName: string       — from session["UserName"]
├── UserLanguageId: int    — from session["UserLanguageId"]
├── IsInitialized: bool    — true if session was read during SSR
└── IsClientUser: bool     — computed: ClientId.HasValue && ClientId.Value > 0
```

### What the [User] Table Provides (DB record)

```
User entity (Infrastructure.Data.Entities.User)
├── UserId: Guid           — matches IUserSessionContext.UserId
├── SiteId: int            — matches IUserSessionContext.SiteId
├── ClientId: int?
├── IsInternal: bool       — key for business logic (internal vs external user)
├── Enabled: bool?
├── FullName: string?
├── UserName: string?
├── Email: string?
├── Title: string?
├── OfficePhone: string?
├── CellPhone: string?
├── WorkArea: string?
├── EmployeeNumber: string?
├── KombitUuid: Guid?
├── CreateDate: DateTime
├── ModifiedDate: DateTime?
└── (ObjectData: string? — XML, rarely needed)
```

### Current Problem: Redundant User Lookup in ActivityService

```csharp
// ActivityService.cs — line 51
var currentUserGuid = await GetUserGuidAsync(context, _sessionContext.UserName, ct);

// Private method queries aspnet_Users BY USERNAME to get the Guid:
private async Task<Guid?> GetUserGuidAsync(SignaturDbContext context, string userName, CancellationToken ct)
{
    var user = await context.AspnetUsers
        .Where(u => u.UserName == userName)
        .Select(u => u.UserId)
        .FirstOrDefaultAsync(ct);
    return user == default ? null : user;
}
```

**The redundancy:** `IUserSessionContext.UserId` ALREADY IS the Guid from the legacy session. The `GetUserGuidAsync` call is therefore unnecessary overhead — it queries `aspnet_Users` to return the same value that session already provides. Additionally, the `aspnet_Users` UserId (from `aspnet_Membership` schema) is the ASP.NET Membership Guid, which is DIFFERENT from the `[User]` table's UserId. The legacy `AtlantaUser` uses `Guid UserId` directly from the `[User]` table. The `IUserSessionContext.UserId` comes from `session["UserId"]` which stores `aUser.UserId` — the `[User]` table's Guid, not the `aspnet_Users` Guid.

**Critical finding:** `ActivityService.GetUserGuidAsync` queries `aspnet_Users.UserId` (the ASP.NET Membership Guid) and uses it to filter `Eractivity.Responsible` and `Eractivity.CreatedBy`. These columns reference the `[User]` table's UserId, NOT the `aspnet_Users.UserId`. This is an existing subtle mismatch. `ICurrentUserService` should use `IUserSessionContext.UserId` (the `[User]` table's Guid) as the authoritative source for activity filtering — which is architecturally correct.

## Standard Stack

### Core (all already in project)
| Component | Location | Purpose |
|-----------|----------|---------|
| `IDbContextFactory<SignaturDbContext>` | Infrastructure DI | Safe EF Core factory for Blazor Server |
| `IUserSessionContext` | Application/Interfaces | Session data source for UserId |
| `User` entity | Infrastructure/Data/Entities | The DB row to load |
| `SignaturDbContext.Users` | Infrastructure/Data | DbSet for User table queries |

### New Components to Create
| Component | Project Layer | Purpose |
|-----------|--------------|---------|
| `ICurrentUserService` | Application/Interfaces | Contract for DB-backed current user |
| `CurrentUserService` | Infrastructure/Services | Implementation: lazy-loads User from DB |

### No New NuGet Packages Required
Everything needed is already present. This is purely an abstraction over existing EF Core + session infrastructure.

## Architecture Patterns

### Recommended Project Structure

```
src/SignaturPortal.Application/
└── Interfaces/
    ├── IUserSessionContext.cs          (exists — DO NOT CHANGE)
    └── ICurrentUserService.cs          (NEW)

src/SignaturPortal.Infrastructure/
├── Services/
│   ├── ActivityService.cs              (MODIFY — remove GetUserGuidAsync, use ICurrentUserService)
│   ├── PermissionHelperService.cs      (no change needed — uses UserName, not Guid)
│   ├── PermissionService.cs            (no change needed — uses UserName, not Guid)
│   └── CurrentUserService.cs           (NEW)
└── DependencyInjection.cs              (MODIFY — register CurrentUserService as Scoped)
```

### Pattern 1: Scoped Lazy-Load with Null Safety

The service is Scoped (one per Blazor circuit). It lazy-loads the User record on first access. If `IUserSessionContext.IsInitialized` is false (no session) or `UserId` is null, it returns null gracefully.

```csharp
// Source: derived from existing PermissionService caching pattern in this codebase
public interface ICurrentUserService
{
    /// <summary>
    /// The current user's Guid, taken from IUserSessionContext.
    /// Returns null if session is not initialized or user is not logged in.
    /// </summary>
    Guid? UserId { get; }

    /// <summary>
    /// Lazy-loads the current user's [User] table record.
    /// Returns null if not initialized or user not found in DB.
    /// Cached for the lifetime of the Blazor circuit (Scoped).
    /// </summary>
    Task<User?> GetCurrentUserAsync(CancellationToken ct = default);
}
```

```csharp
// Source: Infrastructure/Services/CurrentUserService.cs (NEW)
// Mirrors PermissionService caching pattern (already in this codebase)
public class CurrentUserService : ICurrentUserService
{
    private readonly IDbContextFactory<SignaturDbContext> _contextFactory;
    private readonly IUserSessionContext _session;
    private User? _cachedUser;
    private bool _loaded;

    public CurrentUserService(
        IDbContextFactory<SignaturDbContext> contextFactory,
        IUserSessionContext session)
    {
        _contextFactory = contextFactory;
        _session = session;
    }

    public Guid? UserId => _session.UserId;

    public async Task<User?> GetCurrentUserAsync(CancellationToken ct = default)
    {
        if (_loaded)
            return _cachedUser;

        _loaded = true;

        if (!_session.IsInitialized || !_session.UserId.HasValue)
            return null;

        await using var db = await _contextFactory.CreateDbContextAsync(ct);
        // No tenant filter needed: User table has no global query filter by design.
        // See SignaturDbContext.Custom.cs comment: User data accessed through ERActivityMember joins.
        _cachedUser = await db.Users
            .Where(u => u.UserId == _session.UserId.Value)
            .FirstOrDefaultAsync(ct);

        return _cachedUser;
    }
}
```

### Pattern 2: Refactored ActivityService — Use Session UserId Directly

Replace the private `GetUserGuidAsync` (which queries `aspnet_Users` by UserName to get a Guid) with `_currentUserService.UserId` from session. The `[User]` table's UserId stored in session IS the correct Guid for filtering `Eractivity.Responsible` and `Eractivity.CreatedBy`.

```csharp
// Before (REMOVE):
var currentUserGuid = await GetUserGuidAsync(context, _sessionContext.UserName, ct);

// After (USE):
var currentUserGuid = _currentUserService.UserId; // direct from session, no DB query
```

Constructor injection change:
```csharp
public ActivityService(
    IDbContextFactory<SignaturDbContext> contextFactory,
    IUserSessionContext sessionContext,
    IPermissionService permissionService,
    ICurrentUserService currentUserService)  // ADD
```

### Pattern 3: DI Registration (Scoped)

```csharp
// DependencyInjection.cs — add in Infrastructure layer
services.AddScoped<ICurrentUserService, CurrentUserService>();
```

Scoped lifetime is correct:
- One instance per Blazor Server circuit (same as `IUserSessionContext`, `IPermissionService`, `IPermissionHelper`)
- Caches the User record for the circuit lifetime — no repeated DB hits
- Disposed when the circuit ends

### Anti-Patterns to Avoid

- **Singleton lifetime:** The service holds user-specific data. Singleton would share state across all users — catastrophic.
- **Transient lifetime:** Would re-query DB on every injection. Wasteful and defeats caching.
- **Returning `User` entity directly to components:** Components should inject `ICurrentUserService`, not `User` entities. The service is the abstraction point.
- **Blocking on Task in constructor:** The lazy-load must be async (`GetCurrentUserAsync`). Never use `.Result` or `.GetAwaiter().GetResult()` in Blazor Server.
- **Calling GetCurrentUserAsync during SSR without session:** Session may be initializing — always check `IUserSessionContext.IsInitialized` first (already handled by the null-guard in the implementation above).
- **Adding global query filter to User table:** The existing codebase explicitly comments that `[User]` has no global query filter because it is accessed through already-filtered joins. Do not add one.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| User lookup cache | Custom dictionary<Guid, User> in a static/singleton | Scoped `CurrentUserService` with `_cachedUser` field | Scoped DI handles lifetime correctly; static state leaks between users |
| Session-to-DB bridge | Re-query aspnet_Users by UserName to get Guid | Use `IUserSessionContext.UserId` directly | UserId is already in session as Guid; aspnet_Users query is redundant and may return the wrong Guid (membership vs [User] table) |
| Thread safety for cache | Locking / ConcurrentDictionary | No locking needed in Blazor Server | Blazor Server components run single-threaded per circuit; concurrent access within one circuit is not possible |

**Key insight:** The `_loaded` boolean flag (rather than null-checking `_cachedUser`) handles the "user not found in DB" case gracefully — it prevents an infinite retry loop if the user record truly does not exist in the `[User]` table.

## Common Pitfalls

### Pitfall 1: Confusing aspnet_Users.UserId with [User].UserId

**What goes wrong:** Querying `aspnet_Users` by UserName to get a Guid, then using that Guid to filter `Eractivity.Responsible` — which references the `[User]` table's UserId. These two Guids are DIFFERENT fields from different tables (ASP.NET Membership vs the application's User table).

**Why it happens:** The existing `ActivityService.GetUserGuidAsync` made this mistake. It queries `aspnet_Users.UserId` but `Eractivity.Responsible` stores `[User].UserId`.

**How to avoid:** Always use `IUserSessionContext.UserId` for filtering activities. The session stores `aUser.UserId` from the legacy `AtlantaUser` object, which is the `[User]` table's UserId — the correct value for activity filtering.

**Warning signs:** Non-admin users see no activities (filter never matches), or the wrong user's activities appear.

### Pitfall 2: Loading User in Constructor Instead of Lazy-Loading

**What goes wrong:** Attempting to call `GetCurrentUserAsync()` in the service constructor or `OnInitialized` before the session is populated.

**Why it happens:** `IUserSessionContext` is populated by `UserSessionMiddleware` during SSR. In some timing scenarios (e.g., the service is resolved before middleware has run), `IsInitialized` is false.

**How to avoid:** Use lazy-loading — only load the User record when `GetCurrentUserAsync` is first called from a component's `OnInitializedAsync`. By then, the session is always populated.

**Warning signs:** `_session.IsInitialized` is false when `GetCurrentUserAsync` is first called; returns null even for logged-in users.

### Pitfall 3: ICurrentUserService Not Available During SignalR (Post-SSR)

**What goes wrong:** Expecting the `User` entity to contain the latest DB values after a circuit has been running for hours.

**Why it happens:** `CurrentUserService` loads the `User` record once and caches it. Like `IUserSessionContext`, it is a point-in-time snapshot.

**How to avoid:** This is by design and acceptable. Document that user data (FullName, IsInternal, etc.) is loaded once at circuit start. If user record changes matter, a full page reload is required. This matches legacy WebForms behavior.

**Warning signs:** User's FullName changes in DB during an active circuit, but the Blazor app still shows the old name.

### Pitfall 4: Naming Collision with IUserSessionContext

**What goes wrong:** Both interfaces provide similar user data (UserId, SiteId, ClientId), creating confusion about which to use when.

**Why it happens:** Both exist for different purposes — `IUserSessionContext` owns session identity, `ICurrentUserService` owns the DB record.

**How to avoid:** Clear rule: use `IUserSessionContext` for session-level identity (SiteId, ClientId, IsClientUser, UserName). Use `ICurrentUserService` for DB-backed user data (FullName, IsInternal, Enabled, Email). Components and services should inject whichever is semantically appropriate for their use case.

## Code Examples

Verified patterns from existing codebase:

### Existing PermissionService Caching Pattern (reference for ICurrentUserService)

```csharp
// Source: src/SignaturPortal.Infrastructure/Services/PermissionService.cs
public class PermissionService : IPermissionService
{
    private readonly IDbContextFactory<SignaturDbContext> _contextFactory;
    private IReadOnlySet<int>? _cachedPermissions;
    private string? _cachedUserName;

    public async Task<IReadOnlySet<int>> GetUserPermissionsAsync(string userName, CancellationToken ct = default)
    {
        if (_cachedPermissions is not null && string.Equals(_cachedUserName, userName, ...))
            return _cachedPermissions;

        await using var db = await _contextFactory.CreateDbContextAsync(ct);
        // ... query ...
        _cachedPermissions = new HashSet<int>(permissionIds);
        _cachedUserName = userName;
        return _cachedPermissions;
    }
}
```

CurrentUserService uses the same structural pattern but simpler (one user, not parameterized).

### ActivityService — Current (to be refactored)

```csharp
// Source: src/SignaturPortal.Infrastructure/Services/ActivityService.cs
// GetUserGuidAsync queries aspnet_Users by UserName — this is the method to remove
private async Task<Guid?> GetUserGuidAsync(SignaturDbContext context, string userName, CancellationToken ct)
{
    var user = await context.AspnetUsers
        .Where(u => u.UserName == userName)
        .Select(u => u.UserId)
        .FirstOrDefaultAsync(ct);
    return user == default ? null : user;
}
```

### ActivityService — Target (after refactor)

```csharp
// AFTER: UserId comes directly from session via ICurrentUserService (no DB query)
var currentUserGuid = _currentUserService.UserId; // Guid? from IUserSessionContext

// Permission-based filtering for non-admin users
if (!hasAdminAccess && currentUserGuid.HasValue)
{
    query = query.Where(a =>
        a.Responsible == currentUserGuid.Value ||
        a.CreatedBy == currentUserGuid.Value);
}
```

### User Table Query (no tenant filter — intentional)

```csharp
// Source: SignaturDbContext.Custom.cs comment confirms: [User] table has NO global query filter
// "User data is accessed only through ERActivityMember joins (already tenant-filtered)."
await using var db = await _contextFactory.CreateDbContextAsync(ct);
var user = await db.Users
    .Where(u => u.UserId == _session.UserId.Value)
    .FirstOrDefaultAsync(ct);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Per-service private `GetUserGuidAsync` | Centralized `ICurrentUserService.UserId` | This phase | Eliminates redundant DB query; fixes Guid table confusion |
| `IUserSessionContext` as sole user context | Session (IUserSessionContext) + DB (ICurrentUserService) | This phase | Services can now access full User record without duplicating lookup logic |

**Deprecated/outdated:**
- `ActivityService.GetUserGuidAsync`: Replace with `ICurrentUserService.UserId`. The private method queries the wrong table's Guid (aspnet_Users vs [User]) and does redundant work.

## Open Questions

1. **Should ICurrentUserService expose individual properties or just the User entity?**
   - What we know: `PermissionHelperService` uses `IUserSessionContext.UserName` (string). `ActivityService` currently uses a Guid for filtering. The `User` entity has `IsInternal`, `Enabled`, `FullName`, `Email`.
   - What's unclear: Whether future phases need individual sugar properties on the interface (e.g., `IsInternal`, `FullName`) or if returning the `User` entity is sufficient.
   - Recommendation: Return `Task<User?>` from `GetCurrentUserAsync()` plus a synchronous `Guid? UserId` property (delegating to session). Callers access entity properties directly. Add sugar properties to the interface only if multiple callers need the same property — YAGNI principle applies.

2. **Should ActivityService also expose the current User's full record for any display purposes?**
   - What we know: Activity list and detail pages currently resolve user names via correlated subqueries in SQL. The current user is not displayed as their own name on these pages.
   - What's unclear: Whether Phase 4 (write operations) will need the current user's FullName for display (e.g., "Created by: [logged-in user name]").
   - Recommendation: Implement `GetCurrentUserAsync()` now and the Phase 4 planner can use it if needed. No scope creep required here.

3. **Should the _Imports.razor gap from 03.7 verification be fixed in this phase?**
   - What we know: The 03.7 verification found that `_Imports.razor` was missing `@using SignaturPortal.Web.Components.Auth`. The human testing commit (`40d4765`) confirmed the redirect works via incognito testing. Reading `_Imports.razor` now shows line 14: `@using SignaturPortal.Web.Components.Auth` — it IS present. The gap was fixed as part of 03.7 completion.
   - Recommendation: No action needed. This is already resolved.

## Sources

### Primary (HIGH confidence)
- Direct codebase inspection: `src/SignaturPortal.Infrastructure/Services/ActivityService.cs` — confirmed `GetUserGuidAsync` queries `aspnet_Users` by UserName
- Direct codebase inspection: `src/SignaturPortal.Application/Interfaces/IUserSessionContext.cs` — confirms `UserId: Guid?` available from session
- Direct codebase inspection: `src/SignaturPortal.Infrastructure/Data/Entities/User.cs` — full User entity fields confirmed
- Direct codebase inspection: `src/SignaturPortal.Infrastructure/Data/SignaturDbContext.Custom.cs` — confirms `[User]` table has no global query filter by design
- Direct codebase inspection: `src/SignaturPortal.Infrastructure/Services/PermissionService.cs` — caching pattern to follow
- Direct codebase inspection: `src/SignaturPortal.Infrastructure/DependencyInjection.cs` — established registration pattern
- Legacy code: `C:/Dev/Dev3Org/AtlantaSignatur/Library/GenericObjects/GenericObjects.cs` line 4807 — `AtlantaUser.UserId` is `Guid` (the `[User]` table Guid, not the aspnet_Users Guid)
- Direct codebase inspection: `src/SignaturPortal.Web/Components/_Imports.razor` — confirms `@using SignaturPortal.Web.Components.Auth` is present (03.7 gap fixed)

### Secondary (MEDIUM confidence)
- Blazor Server scoped DI lifetime behavior: one instance per circuit — consistent with `IPermissionService`, `IUserSessionContext` registration patterns already established in this codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — all components already exist in codebase, no new libraries needed
- Architecture: HIGH — follows exact same scoped lazy-loading pattern as PermissionService (verified by code reading)
- Pitfalls: HIGH — Guid table confusion (aspnet_Users vs [User]) verified by direct code inspection; others are well-understood Blazor Server patterns
- `GetUserGuidAsync` redundancy: HIGH — directly confirmed: session already holds UserId as Guid, private method queries aspnet_Users unnecessarily

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (stable internal codebase patterns, no external dependency changes)
